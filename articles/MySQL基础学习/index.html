<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-2EuuuTEL7g">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heavytiger.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":18,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的 RDBMS(Relational Database Management System，关系数据库管理系统)应用软件之一。 MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL基础学习">
<meta property="og:url" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="HeavyTiger&#39;s Blogs">
<meta property="og:description" content="MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的 RDBMS(Relational Database Management System，关系数据库管理系统)应用软件之一。 MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813111516192-16288245176381.png">
<meta property="og:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813112018853-16288248202802.png">
<meta property="og:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813113700031.png">
<meta property="og:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813113838394.png">
<meta property="og:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813114333554.png">
<meta property="article:published_time" content="2021-08-10T04:51:23.000Z">
<meta property="article:modified_time" content="2021-08-10T04:51:23.000Z">
<meta property="article:author" content="喵式重战">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210813111516192-16288245176381.png">

<link rel="canonical" href="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL基础学习 | HeavyTiger's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
   <!--动态线条背景-->
    <script type="text/javascript"color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
   
   <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HeavyTiger's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">逆水行舟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/HeavyTiger" class="github-corner" title="喵喵喵~~~" aria-label="喵喵喵~~~" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    
    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="喵式重战">
      <meta itemprop="description" content="人的一切痛苦，本质上都是对自己无能的愤怒。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HeavyTiger's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL基础学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-10 12:51:23" itemprop="dateCreated datePublished" datetime="2021-08-10T12:51:23+08:00">2021-08-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">数据库学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!--此处为希望博客在首页显示的内容-->

<p>MySQL是一个<strong>关系型数据库管理系统，</strong>由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的 RDBMS(Relational Database Management System，关系数据库管理系统)应用软件之一。</p>
<p>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般网站的开发都选择 MySQL 作为网站数据库。</p>
<span id="more"></span>
<!-- markdownlint-disable MD041 MD002-->

<h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h3 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h3><p>首先我们需要在Oracle的官网下载MySQL的安装包，推荐下载ZIP压缩包，使用压缩包可以避免注册表产生的相关问题，下载完成后，对ZIP进行解压。</p>
<p>这里选择了下载8.025版本，可能会存在问题，理论上安装5.7版本应该是最稳定的，不过鉴于学习的目的，先瞎鼓捣尝试一下。</p>
<p>解压完成后，在根目录中，我们需要新建一个my.ini文件，该文件是mysql的配置文件，可以对mysql进行相关的配置。我的配置如下所示（网上偷师学到的，不保证靠谱，<strong>记住mysql安装目录一定要改成自己的！</strong>）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment">#设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\SourceFiles\mysql</span><br><span class="line"><span class="comment">#设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\SourceFiles\mysql\Data</span><br><span class="line"><span class="comment">#允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment">#允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">#服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="comment">#创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment">#默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment">#设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment">#设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br></pre></td></tr></table></figure>

<p>之后配置系统变量，将<strong>mysql\bin</strong>目录添加到path环境变量中去，方便在命令行界面使用命令。</p>
<p>使用管理员权限打开cmd界面（<strong>否则将没有权限开启服务</strong>）</p>
<p>将路径切换到mysql的bin目录下，使用命令<code>mysqld -install</code>安装mysql。再输入<code>mysqld --initialize-insecure --user=mysql</code>初始化数据文件（可以看到出现了data文件夹，里面以db形式存放了数据库的配置信息）</p>
<p>之后启动mysql，使用<code>mysql -u root -p</code>进入mysql管理界面（此时密码为空，直接回车进入即可）</p>
<p>进入界面后，可以更改root密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure>

<p>(记住SQL语句输入完成后需要输入<code>;</code>)</p>
<p>(输入<code>flash privileges</code>;刷新权限)</p>
<p>最后重启mysql即可正常进行使用：</p>
<p>在管理员权限下的控制台输入：</p>
<ul>
<li><code>net stop mysql</code> 停止mysql服务</li>
<li><code>net start mysql</code> 启动mysql服务</li>
</ul>
<p>之后尝试用<code>mysql -u&#39;root&#39; -p&#39;password&#39;</code>进行登录(‘root’ 可以修改为自己的<code>用户</code> ‘password’改成自己设置的<code>密码</code>，如<code>123456</code>，<strong>切记-u和’root’ 、-p和’password’ 之间没有空格！</strong>)</p>
<blockquote>
<p><strong>注意：若mysql服务安装错误，可以使用<code>sc delete mysql</code>语句在管理员权限下清空服务</strong></p>
</blockquote>
<h3 id="SQL可视化软件"><a href="#SQL可视化软件" class="headerlink" title="SQL可视化软件"></a>SQL可视化软件</h3><ul>
<li>SQLyog        体积较小，功能较为完善</li>
<li>Navicat       体积较大，功能较多</li>
</ul>
<p>本次尝试使用Navicat对数据库进行可视化管理！</p>
<p><img src="image-20210813111516192-16288245176381.png" alt="Navicat主界面"></p>
<center>Navicat主界面如图所示：</center>

<p><img src="image-20210813112018853-16288248202802.png" alt="尝试连接到localhost:3306数据库"></p>
<center>尝试连接到localhost:3306数据库：</center>

<h3 id="测试基本的新建数据库操作"><a href="#测试基本的新建数据库操作" class="headerlink" title="测试基本的新建数据库操作"></a>测试基本的新建数据库操作</h3><blockquote>
<p>要求：新建一个数据库，名称为：school</p>
<p>​           新建一张表，表名为：<code>student</code></p>
<p>​           新建一些字段：id, name, age等</p>
</blockquote>
<p><img src="image-20210813113700031.png" alt="image-20210813113700031"></p>
<center> 新建数据库，名称为school，使用utf8编码，排序规则使用utf8_general_ci</center>

<p><img src="image-20210813113838394.png" alt="image-20210813113838394"></p>
<center> 使用InnoDB引擎，编码集选择utf8，排序规则选择utf8_general_ci</center>

<p><img src="image-20210813114333554.png" alt="image-20210813114333554"></p>
<h3 id="使用命令行界面连接数据库"><a href="#使用命令行界面连接数据库" class="headerlink" title="使用命令行界面连接数据库"></a>使用命令行界面连接数据库</h3><p>使用语句<code>mysql -uroot -p</code>，之后输入密码，密码正确后，即可正确进入MySQL</p>
<p>MySQL中，使用<code>--</code>作为注释，例如<code>-- 注释</code></p>
<p><strong>简单的一些基本语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;		-- 展示所有的数据库</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| school             |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">-- 使用ctrl+c可以强行终止mysql语句</span><br><span class="line"></span><br><span class="line">mysql&gt; use school	-- 切换数据库 使用use加数据库名</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;	-- 展示该数据库中的所有的表</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_school |</span><br><span class="line">+------------------+</span><br><span class="line">| student          |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; status	-- 查看当前状态</span><br><span class="line">--------------</span><br><span class="line">D:\SourceFiles\mysql\bin\mysql.exe  Ver 8.0.25 for Win64 on x86_64 (MySQL Community Server - GPL)</span><br><span class="line"></span><br><span class="line">Connection id:          12</span><br><span class="line">Current database:       school</span><br><span class="line">Current user:           root@localhost</span><br><span class="line">SSL:                    Cipher in use is TLS_AES_256_GCM_SHA384</span><br><span class="line">Using delimiter:        ;</span><br><span class="line">Server version:         8.0.25 MySQL Community Server - GPL</span><br><span class="line">Protocol version:       10</span><br><span class="line">Connection:             localhost via TCP/IP</span><br><span class="line">Server characterset:    utf8mb4</span><br><span class="line">Db     characterset:    utf8mb3</span><br><span class="line">Client characterset:    utf8mb4</span><br><span class="line">Conn.  characterset:    utf8mb4</span><br><span class="line">TCP port:               3306</span><br><span class="line">Binary data as:         Hexadecimal</span><br><span class="line">Uptime:                 4 days 7 hours 42 min 40 sec</span><br><span class="line"></span><br><span class="line">Threads: 2  Questions: 224  Slow queries: 0  Opens: 199  Flush tables: 3  Open tables: 118  Queries per second avg: 0.000</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">mysql&gt; describe student;	-- 显示student表中的信息</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| id    | int          | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(100) | NO   |     | NULL    |       |</span><br><span class="line">| age   | int          | NO   |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show columns from student;	-- 显示student表中的信息，使用describe较为简单</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| id    | int          | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(100) | NO   |     | NULL    |       |</span><br><span class="line">| age   | int          | NO   |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit；	-- 退出与MySQL的连接</span><br><span class="line"></span><br><span class="line">-- 单行注释（SQL本身的注释）</span><br><span class="line"></span><br><span class="line">/*	SQL的多行注释</span><br><span class="line">hello，</span><br><span class="line">world！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>数据库的基本语言</strong>    核心即CRUD业务(增删改查)</p>
<blockquote>
<p>DDL    定义</p>
<p>DML    操作</p>
<p>DQL    查询</p>
<p>DCL    控制</p>
</blockquote>
<h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>操作数据库 &gt; 操作数据库中的表 &gt; 操作数据库中的表的数据</p>
<p><strong>mysql关键字不区分大小写</strong></p>
<h3 id="SQL基本信息"><a href="#SQL基本信息" class="headerlink" title="SQL基本信息"></a>SQL基本信息</h3><h4 id="表（table）"><a href="#表（table）" class="headerlink" title="表（table）"></a>表（table）</h4><p><strong>某种特定类型数据的结构化清单</strong></p>
<p>数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。</p>
<blockquote>
<p><strong>表名</strong> 表名的唯一性取决于多个因素，如数据库名和表名等的结合。这表示，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中却可以使用相同的表名。</p>
</blockquote>
<h4 id="模式（schema）"><a href="#模式（schema）" class="headerlink" title="模式（schema）"></a>模式（schema）</h4><p><strong>关于数据库和表的布局及特性的信息</strong></p>
<blockquote>
<p>有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。</p>
</blockquote>
<h4 id="列（column）表中的一个字段"><a href="#列（column）表中的一个字段" class="headerlink" title="列（column）表中的一个字段"></a>列（column）表中的一个字段</h4><p><strong>所有表都是由一个或多个列组成的。</strong></p>
<blockquote>
<p><strong>分解数据</strong> 正确地将数据分解为多个列极为重要。例如，城市、州、邮政编码应该总是独立的列。通过把它分解开，才有可能利用特定的列对数据进行排序和过滤（如，找出特定州或特定城市的所有顾客）。如果城市和州组合在一个列中，则按州进行排序或过滤会很困难。</p>
</blockquote>
<blockquote>
<p><strong>数据类型（datatype）</strong>所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p>
</blockquote>
<h4 id="行（row）-表中的一个记录"><a href="#行（row）-表中的一个记录" class="headerlink" title="行（row） 表中的一个记录"></a>行（row） 表中的一个记录</h4><blockquote>
<p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。</p>
</blockquote>
<h4 id="主键（primary-key）"><a href="#主键（primary-key）" class="headerlink" title="主键（primary key）"></a>主键（primary key）</h4><p><strong>一列（或一组列），其值能够唯一区分表中每个行。</strong></p>
<p>唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。</p>
<blockquote>
<p><strong>应该总是定义主键</strong> 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。</p>
</blockquote>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li>
</ul>
<p>主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。</p>
<blockquote>
<p><strong>主键的最好习惯</strong> 除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为：</p>
<ul>
<li>不更新主键列中的值；</li>
<li>不重用主键列的值；</li>
<li>不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。）</li>
</ul>
</blockquote>
<h3 id="导入样例的数据库"><a href="#导入样例的数据库" class="headerlink" title="导入样例的数据库"></a>导入样例的数据库</h3><p>我们使用《MySQL必知必会》内提供的样例表进行操作。</p>
<p>进入书中提供的网址：<a target="_blank" rel="noopener" href="https://forta.com/books/0672327120/">MySQL Crash Course – Ben Forta</a></p>
<p>此时网站提供的样例表下载资源URL为(若不能下载，请尝试挂梯子或者进入网站下载)：<a target="_blank" rel="noopener" href="https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip">点击下载</a></p>
<p>下载完成后存储到磁盘位置，之后使用文件(create.sql  populate.sql)进行样例表的创建。</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>使用mysql命令行界面：</p>
<p>输入创建数据库命令：create database crashcourse;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database crashcourse;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| crashcourse        |</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| school             |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>使用crashcourse作为数据库的名称，便于与《MySQL必知必会》上的案例结合。</p>
<h4 id="选取数据库"><a href="#选取数据库" class="headerlink" title="选取数据库"></a>选取数据库</h4><p>使用use命令：<code>use crashcourse;</code></p>
<h4 id="执行create-sql脚本"><a href="#执行create-sql脚本" class="headerlink" title="执行create.sql脚本"></a>执行create.sql脚本</h4><p>输入执行脚本的命令，即指定数据库的源；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use crashcourse;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; source E:\DataBase\mysql_scripts\create.sql</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<h4 id="执行populate-sql脚本"><a href="#执行populate-sql脚本" class="headerlink" title="执行populate.sql脚本"></a>执行populate.sql脚本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source E:\DataBase\mysql_scripts\populate.sql</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_crashcourse |</span><br><span class="line">+-----------------------+</span><br><span class="line">| customers             |</span><br><span class="line">| orderitems            |</span><br><span class="line">| orders                |</span><br><span class="line">| productnotes          |</span><br><span class="line">| products              |</span><br><span class="line">| vendors               |</span><br><span class="line">+-----------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="查看表列"><a href="#查看表列" class="headerlink" title="查看表列"></a>查看表列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show columns from customers;		-- 使用SHOW COLUMNS展示表列，或者使用DESCRIBE</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| cust_id      | int       | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; describe customers;		-- 使用DESCRIBE展示表列</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| Field        | Type      | Null | Key | Default | Extra          |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">| cust_id      | int       | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| cust_name    | char(50)  | NO   |     | NULL    |                |</span><br><span class="line">| cust_address | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_city    | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_state   | char(5)   | YES  |     | NULL    |                |</span><br><span class="line">| cust_zip     | char(10)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_country | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_contact | char(50)  | YES  |     | NULL    |                |</span><br><span class="line">| cust_email   | char(255) | YES  |     | NULL    |                |</span><br><span class="line">+--------------+-----------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，上述表列中，有一个Extra属性，其中出现了auto_increment; </p>
<p>该属性的含义为自动增加编号而不必自己去进行定义赋值。</p>
<blockquote>
<p><strong>什么是自动增量？</strong> 某些表列需要唯一值。例如，订单编号、雇员ID或（如上面例子中所示的）顾客ID。在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。</p>
</blockquote>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><p>SELECT语句的作用是从一个或者多个表中检索出信息。</p>
<p>为了使用SELECT语句，至少要提供两条信息：</p>
<ol>
<li>想选择什么信息 </li>
<li>以及从什么地方选择</li>
</ol>
<h4 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h4><p>使用语句：<code>select FIELD from TABLE;</code> </p>
<p>此语句检索单个列所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; describe products;</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| prod_id    | char(10)     | NO   | PRI | NULL    |       |</span><br><span class="line">| vend_id    | int          | NO   | MUL | NULL    |       |</span><br><span class="line">| prod_name  | char(255)    | NO   |     | NULL    |       |</span><br><span class="line">| prod_price | decimal(8,2) | NO   |     | NULL    |       |</span><br><span class="line">| prod_desc  | text         | YES  |     | NULL    |       |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select prod_id</span><br><span class="line">    -&gt; from products;		-- 从products表中选择prod_id列，显示数据</span><br><span class="line">+---------+</span><br><span class="line">| prod_id |</span><br><span class="line">+---------+</span><br><span class="line">| ANV01   |</span><br><span class="line">| ANV02   |</span><br><span class="line">| ANV03   |</span><br><span class="line">| FU1     |</span><br><span class="line">| OL1     |</span><br><span class="line">| DTNTR   |</span><br><span class="line">| FB      |</span><br><span class="line">| FC      |</span><br><span class="line">| SAFE    |</span><br><span class="line">| SLING   |</span><br><span class="line">| TNT1    |</span><br><span class="line">| TNT2    |</span><br><span class="line">| JP1000  |</span><br><span class="line">| JP2000  |</span><br><span class="line">+---------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若进行该查询，可能会发现显示出的数据顺序和此处的顺序不相同，原因是未指定排序查询结果，因此返回的数据顺序不具有特殊意义。</p>
</blockquote>
<blockquote>
<p><strong>SQL语句和大小写</strong> 请注意，SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。<br>   许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。</p>
<p>​    不过，一定要认识到虽然SQL是不区分大小写的，但有些标识符（如数据库名、表名、列名）可能不同：在MySQL 4.1及之前的版本中，这些标识符默认是区分大小写的；在MySQL 4.1.1版本中，这些标识符默认是不区分大小写的。<br>​    最佳方式是按照大小写的惯例，且使用时保持一致。</p>
</blockquote>
<blockquote>
<p><strong>使用空格</strong> 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。</p>
</blockquote>
<h4 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h4><blockquote>
<p><strong>逗号</strong> 在选择多个列时，一定要在列名之前加上逗号，最后一个列名不加逗号。</p>
</blockquote>
<p>使用语句：<code>SELECT prod_id, prod_name, prod_price FROM products;</code></p>
<p>此语句指令了3个列名，列名之间使用逗号进行分隔，以此对多个列检索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name, prod_price FROM products;</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| prod_id | prod_name      | prod_price |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">| ANV01   | .5 ton anvil   |       5.99 |</span><br><span class="line">| ANV02   | 1 ton anvil    |       9.99 |</span><br><span class="line">| ANV03   | 2 ton anvil    |      14.99 |</span><br><span class="line">| DTNTR   | Detonator      |      13.00 |</span><br><span class="line">| FB      | Bird seed      |      10.00 |</span><br><span class="line">| FC      | Carrots        |       2.50 |</span><br><span class="line">| FU1     | Fuses          |       3.42 |</span><br><span class="line">| JP1000  | JetPack 1000   |      35.00 |</span><br><span class="line">| JP2000  | JetPack 2000   |      55.00 |</span><br><span class="line">| OL1     | Oil can        |       8.99 |</span><br><span class="line">| SAFE    | Safe           |      50.00 |</span><br><span class="line">| SLING   | Sling          |       4.49 |</span><br><span class="line">| TNT1    | TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT2    | TNT (5 sticks) |      10.00 |</span><br><span class="line">+---------+----------------+------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h4><p>使用语句：<code>SELECT * FROM products;</code></p>
<p>此语句使用通配符(*)，返回表中的所有列，列的顺序不固定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM products;</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single use                          |</span><br><span class="line">| JP2000  |    1005 | JetPack 2000   |      55.00 | JetPack 2000, multi-use                                        |</span><br><span class="line">| OL1     |    1002 | Oil can        |       8.99 | Oil can, red                                                   |</span><br><span class="line">| SAFE    |    1003 | Safe           |      50.00 | Safe with combination lock                                     |</span><br><span class="line">| SLING   |    1003 | Sling          |       4.49 | Sling, one size fits all                                       |</span><br><span class="line">| TNT1    |    1003 | TNT (1 stick)  |       2.50 | TNT, red, single stick                                         |</span><br><span class="line">| TNT2    |    1003 | TNT (5 sticks) |      10.00 | TNT, red, pack of 10 sticks                                    |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该语句可以用来检索未知列，因为通配符可以匹配所有的列名</p>
</blockquote>
<h4 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h4><p>使用SELECT返回的是所有的匹配的行，若不想让每个值在每次都出现，可以使用<code>DISTINCT</code>关键字使得MySQL返回不同的值。</p>
<p>使用语句：<code>SELECT DISTINCT vend_id FROM products;</code></p>
<p>此语句只返回不同的<code>vend_id</code>行，若使用DISTINCT关键字，必须放在列名之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT vend_id FROM products;		-- 使用DISTINCT关键字，查询不同值</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT vend_id FROM products;		-- 不使用DISTINCT关键字，查询所有值</span><br><span class="line">+---------+</span><br><span class="line">| vend_id |</span><br><span class="line">+---------+</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1001 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1002 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1003 |</span><br><span class="line">|    1005 |</span><br><span class="line">|    1005 |</span><br><span class="line">+---------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong> 不能部分使用DISTINCT，若使用则必须所有的列都使用，否则将会检索所有的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT vend_id,</span><br><span class="line">    -&gt; prod_price</span><br><span class="line">    -&gt; FROM products;</span><br><span class="line">+---------+------------+</span><br><span class="line">| vend_id | prod_price |</span><br><span class="line">+---------+------------+</span><br><span class="line">|    1001 |       5.99 |</span><br><span class="line">|    1001 |       9.99 |</span><br><span class="line">|    1001 |      14.99 |</span><br><span class="line">|    1003 |      13.00 |</span><br><span class="line">|    1003 |      10.00 |</span><br><span class="line">|    1003 |       2.50 |</span><br><span class="line">|    1002 |       3.42 |</span><br><span class="line">|    1005 |      35.00 |</span><br><span class="line">|    1005 |      55.00 |</span><br><span class="line">|    1002 |       8.99 |</span><br><span class="line">|    1003 |      50.00 |</span><br><span class="line">|    1003 |       4.49 |</span><br><span class="line">+---------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p>使用语句：<code>SELECT prod_name FROM products LIMIT 5;</code></p>
<p>此语句使用LIMIT进行限制，使得MySQL返回的行数不多于5行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products LIMIT 5;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+ </span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">| Detonator    |</span><br><span class="line">| Bird seed    |</span><br><span class="line">+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>为了得出下一个5行，可以指定要检索的开始行和检索行数：</p>
<p>使用语句：<code>SELECT prod_name FROM products LIMIT 5,5;</code></p>
<p>此语句中：<code>LIMIT 5,5</code>指示Mysql返回从第5行开始的之后5行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products LIMIT 5,5;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| Carrots      |</span><br><span class="line">| Fuses        |</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">| Oil can      |</span><br><span class="line">+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong> 行数从第0行开始，故使用LIMIT 1，1检测出的是第二行而不是第一行。当行数没有足够的行时，使用LIMIT只返回它能返回的行。</p>
<h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>使用语句：<code>SLEECT products.prod_name FROM products;</code></p>
<p>此语句中：限定了一个完全被指定了表和列的列名，在某些特殊情况下，需要使用该条语句！</p>
<h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><p>使用SELECT语句可以检索需要的数据，但是，正如3.1节中所示，并不存在特定的顺序。如果不排序，数据一般将以它在底层表中出现的顺序显示。<strong>这可以是数据最初添加到表中的顺序</strong>。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。<strong>因此，如果不明确控制的话，不能（也不应该）依赖该排序顺序。</strong>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p>
<blockquote>
<p><strong>子句（clause）</strong> SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句，我们在前一章看到过这个子句。<br>为了明确地排序用SELECT语句检索出的数据，可使用<code>ORDER BY</code>子句。<code>ORDER BY</code>子句取一个或多个列的名字，据此对输出进行排序。</p>
</blockquote>
<h4 id="按照单个列排序"><a href="#按照单个列排序" class="headerlink" title="按照单个列排序"></a>按照单个列排序</h4><p>使用语句：<code>SELECT prod_name FROM products ORDER BY prod_name;</code></p>
<p>此语句中：指示了按照prod_name列以字母顺序(字典序)进行数据的排序，使用了ORDER BY子句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products ORDER BY prod_name;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| .5 ton anvil   |</span><br><span class="line">| 1 ton anvil    |</span><br><span class="line">| 2 ton anvil    |</span><br><span class="line">| Bird seed      |</span><br><span class="line">| Carrots        |</span><br><span class="line">| Detonator      |</span><br><span class="line">| Fuses          |</span><br><span class="line">| JetPack 1000   |</span><br><span class="line">| JetPack 2000   |</span><br><span class="line">| Oil can        |</span><br><span class="line">| Safe           |</span><br><span class="line">| Sling          |</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="按照多个列进行排序"><a href="#按照多个列进行排序" class="headerlink" title="按照多个列进行排序"></a>按照多个列进行排序</h4><p>经常会出现需要按照多个列进行排序的情况，例如：希望先按照雇员的姓排序，排序之后再按照雇员的名进行排序(即：公司人员较多，出现较多重复姓氏)，此时若能够按照多个列进行排序，则很有用。</p>
<p>使用语句：<code>SELECT * FROM products ORDER BY vend_id, prod_price;</code></p>
<p>此语句中：使用*获取products中的所有信息，再首先按照<code>vend_id</code>进行升序排序，排序后若出现<code>vend_id</code>相同的行，再按照``prod_price`对价格进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM products ORDER BY vend_id, prod_price;</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| ANV03   |    1001 | 2 ton anvil    |      14.99 | 2 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| FU1     |    1002 | Fuses          |       3.42 | 1 dozen, extra long                                            |</span><br><span class="line">| OL1     |    1002 | Oil can        |       8.99 | Oil can, red                                                   |</span><br><span class="line">| FC      |    1003 | Carrots        |       2.50 | Carrots (rabbit hunting season only)                           |</span><br><span class="line">| TNT1    |    1003 | TNT (1 stick)  |       2.50 | TNT, red, single stick                                         |</span><br><span class="line">| SLING   |    1003 | Sling          |       4.49 | Sling, one size fits all                                       |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| TNT2    |    1003 | TNT (5 sticks) |      10.00 | TNT, red, pack of 10 sticks                                    |</span><br><span class="line">| DTNTR   |    1003 | Detonator      |      13.00 | Detonator (plunger powered), fuses not included                |</span><br><span class="line">| SAFE    |    1003 | Safe           |      50.00 | Safe with combination lock                                     |</span><br><span class="line">| JP1000  |    1005 | JetPack 1000   |      35.00 | JetPack 1000, intended for single use                          |</span><br><span class="line">| JP2000  |    1005 | JetPack 2000   |      55.00 | JetPack 2000, multi-use                                        |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h4><p>数据排序可以按照升序（默认排序顺序），也可以按照降序排序，若使用降序，则必须指定<code>DESC</code>关键字(descent)对列进行降序排序。</p>
<p>使用语句：<code>SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC, prod_name;</code></p>
<p>此语句中：按照倒序（降价）的顺序排序商品，再对产品的名称进行正序排序；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC, prod_name;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| JP2000  |      55.00 | JetPack 2000   |</span><br><span class="line">| SAFE    |      50.00 | Safe           |</span><br><span class="line">| JP1000  |      35.00 | JetPack 1000   |</span><br><span class="line">| ANV03   |      14.99 | 2 ton anvil    |</span><br><span class="line">| DTNTR   |      13.00 | Detonator      |</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">| ANV02   |       9.99 | 1 ton anvil    |</span><br><span class="line">| OL1     |       8.99 | Oil can        |</span><br><span class="line">| ANV01   |       5.99 | .5 ton anvil   |</span><br><span class="line">| SLING   |       4.49 | Sling          |</span><br><span class="line">| FU1     |       3.42 | Fuses          |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若对多个列使用降序排序，则必须对每个列指定<code>DESC</code>关键字。与此同时，若想使用升序排序，需要使用<code>ASC</code>关键字(ascending)，但是事实上不必要如此设定，因为升序排序是默认选项。</p>
</blockquote>
<blockquote>
<p><strong>区分大小写和排序顺序</strong> 在对文本性的数据进行排序时，A与a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。</p>
</blockquote>
<h4 id="查询最值"><a href="#查询最值" class="headerlink" title="查询最值"></a>查询最值</h4><p>使用ORDER BY和LIMIT的组合，可以很方便的找到一列中的最值。</p>
<p>使用语句：<code>SELECT prod_price, prod_name FROM products ORDER BY prod_price DESC LIMIT 1;</code></p>
<p>此语句中：使用了ORDER BY和LIMIT的组合，找到价格最昂贵的物品的价格和名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_price, prod_name FROM products ORDER BY prod_price DESC LIMIT 1;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| prod_price | prod_name    |</span><br><span class="line">+------------+--------------+</span><br><span class="line">|      55.00 | JetPack 2000 |</span><br><span class="line">+------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><p>数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。</p>
<p>一般使用SELECT语句和WHERE子句进行，在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出。</p>
<p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE prod_price = 2.5;</code></p>
<p>此语句中：将查询products表中，prod_price (价格)等于2.5的元素。并将这些行返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price FROM products WHERE prod_price = 2.5;</span><br><span class="line">+---------+------------+</span><br><span class="line">| prod_id | prod_price |</span><br><span class="line">+---------+------------+</span><br><span class="line">| FC      |       2.50 |</span><br><span class="line">| TNT1    |       2.50 |</span><br><span class="line">+---------+------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>SQL过滤与应用过滤</strong> 数据也可以在应用层过滤。为此目的，SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。<br>    通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。</p>
</blockquote>
<blockquote>
<p>若使用ORDER BY和WHERE子句，应该将ORDER BY位于WHERE之后</p>
</blockquote>
<h4 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h4><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;&gt;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在指定的两个值之间</td>
</tr>
</tbody></table>
<p>MySQL支持以上的所有操作符，可以用在WHERE后，进行条件判断</p>
<h4 id="检查单个值"><a href="#检查单个值" class="headerlink" title="检查单个值"></a>检查单个值</h4><p>使用语句：<code>SELECT * FROM products WHERE prod_name = &#39;fuses&#39;;</code></p>
<p>此语句中：检查prod_name为’fuses’的行，它返回prod_name的值为Fuses的一行。<code>MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配。</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM products WHERE prod_name = &#x27;fuses&#x27;;</span><br><span class="line">+---------+---------+-----------+------------+---------------------+</span><br><span class="line">| prod_id | vend_id | prod_name | prod_price | prod_desc           |</span><br><span class="line">+---------+---------+-----------+------------+---------------------+</span><br><span class="line">| FU1     |    1002 | Fuses     |       3.42 | 1 dozen, extra long |</span><br><span class="line">+---------+---------+-----------+------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE prod_price &lt; 10;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price FROM products WHERE prod_price &lt; 10;</span><br><span class="line">+---------------+------------+</span><br><span class="line">| prod_name     | prod_price |</span><br><span class="line">+---------------+------------+</span><br><span class="line">| .5 ton anvil  |       5.99 |</span><br><span class="line">| 1 ton anvil   |       9.99 |</span><br><span class="line">| Carrots       |       2.50 |</span><br><span class="line">| Fuses         |       3.42 |</span><br><span class="line">| Oil can       |       8.99 |</span><br><span class="line">| Sling         |       4.49 |</span><br><span class="line">| TNT (1 stick) |       2.50 |</span><br><span class="line">+---------------+------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>



<p>使用语句：<code>SELECT * FROM products WHERE prod_price BETWEEN 5 AND 10;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM products WHERE prod_price BETWEEN 5 AND 10;</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name      | prod_price | prod_desc                                                      |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">| ANV01   |    1001 | .5 ton anvil   |       5.99 | .5 ton anvil, black, complete with handy hook                  |</span><br><span class="line">| ANV02   |    1001 | 1 ton anvil    |       9.99 | 1 ton anvil, black, complete with handy hook and carrying case |</span><br><span class="line">| FB      |    1003 | Bird seed      |      10.00 | Large bag (suitable for road runners)                          |</span><br><span class="line">| OL1     |    1002 | Oil can        |       8.99 | Oil can, red                                                   |</span><br><span class="line">| TNT2    |    1003 | TNT (5 sticks) |      10.00 | TNT, red, pack of 10 sticks                                    |</span><br><span class="line">+---------+---------+----------------+------------+----------------------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="不匹配检查"><a href="#不匹配检查" class="headerlink" title="不匹配检查"></a>不匹配检查</h4><p>使用语句：<code>SELECT vend_id, prod_name FROM products WHERE vend_id != 1003 AND vend_id &lt;&gt; 1001;</code></p>
<p>此语句中：使用<code>!=</code>和<code>&lt;&gt;</code>进行不匹配检查，索引不满足需求的行，可以看到使用两种操作符可以得到一样的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, prod_name FROM products WHERE vend_id != 1003 AND vend_id &lt;&gt; 1001;</span><br><span class="line">+---------+--------------+</span><br><span class="line">| vend_id | prod_name    |</span><br><span class="line">+---------+--------------+</span><br><span class="line">|    1002 | Fuses        |</span><br><span class="line">|    1002 | Oil can      |</span><br><span class="line">|    1005 | JetPack 1000 |</span><br><span class="line">|    1005 | JetPack 2000 |</span><br><span class="line">+---------+--------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="范围值检查"><a href="#范围值检查" class="headerlink" title="范围值检查"></a>范围值检查</h4><p>使用<code>BETWEEN</code>操作符，可以用来进行范围值检查</p>
<p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 5 AND 10 AND vend_id != 1001;</code></p>
<p>此语句中：查找价格在5到10之间且id不为1001的所有行。<strong>在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有值，包括指定的开始值和结束值。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price FROM products WHERE prod_price BETWEEN 5 AND 10 AND vend_id != 1001;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><p>在创建表时，可以指定当前的列中能否存在不包含值，若一个列不包含值，视作包含空值NULL</p>
<blockquote>
<p>NULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。</p>
</blockquote>
<p>使用<code>IS NULL</code>子句可以返回有空值的列，例如查没有填写家庭地址的客户。</p>
<p>使用语句：<code>SELECT * FROM customers WHERE cust_email IS NULL;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM customers WHERE cust_email IS NULL;</span><br><span class="line">+---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+</span><br><span class="line">| cust_id | cust_name   | cust_address     | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |</span><br><span class="line">+---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+</span><br><span class="line">|   10002 | Mouse House | 333 Fromage Lane | Columbus  | OH         | 43333    | USA          | Jerry Mouse  | NULL       |</span><br><span class="line">|   10005 | E Fudd      | 4545 53rd Street | Chicago   | IL         | 54545    | USA          | E Fudd       | NULL       |</span><br><span class="line">+---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NULL与不匹配</strong> 在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p>
<p>因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。</p>
</blockquote>
<h3 id="组合过滤数据"><a href="#组合过滤数据" class="headerlink" title="组合过滤数据"></a>组合过滤数据</h3><p>我们在使用WHERE子句时，还可以使用AND OR NOT IN这样的操作符进行匹配。</p>
<h4 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a>AND操作符</h4><p>使用语句：<code>SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10 AND prod_name != &#39;Sling&#39;;</code></p>
<p>此语句中：使用了AND操作符来进行匹配，若存在多个与逻辑，需要使用多个AND。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10 AND prod_name != &#x27;Sling&#x27;;</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| prod_id | prod_price | prod_name      |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">| FB      |      10.00 | Bird seed      |</span><br><span class="line">| FC      |       2.50 | Carrots        |</span><br><span class="line">| TNT1    |       2.50 | TNT (1 stick)  |</span><br><span class="line">| TNT2    |      10.00 | TNT (5 sticks) |</span><br><span class="line">+---------+------------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="OR操作符"><a href="#OR操作符" class="headerlink" title="OR操作符"></a>OR操作符</h4><p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h4><p>WHERE语句可以包含任意数目的AND和OR操作符，但是若过于依赖其默认的排序，很可能出现匹配的问题，我们需要使用圆括号帮助其进行优先匹配。</p>
<p>例如，若想查询价格为10元以上,且编号1002或1003，若使用语句<code>SELECT prod_name, prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10;</code></p>
<p>一定会产生错误，原因是，SQL在处理OR操作符之前，会优先处理AND操作符，因此这句话中，它会认为应该先找出编号为1003并且价格大于10的产品，或者找到编号为1002的产品，因此会出现有编号为1002的产品的价格少于10。从而产生错误，因此可以使用括号增加优先级，如下所示：</p>
<p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到此时结果正确，查询结果正常。</p>
<blockquote>
<p><strong>在WHERE子句中使用圆括号</strong> 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p>
</blockquote>
<h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p>圆括号在WHERE子句中还有另外一种用法。IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。</p>
<p>使用语句：<code>SELECT prod_name, prod_price FROM products WHERE vend_id IN (1002, 1003) ORDER BY prod_name;</code></p>
<p>此语句中：使用了IN匹配了vend_id中，所有编号为1002和1003的值，并按照prod_name的字典序排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, prod_price FROM products WHERE vend_id IN (1002, 1003) ORDER BY prod_name;</span><br><span class="line">+----------------+------------+</span><br><span class="line">| prod_name      | prod_price |</span><br><span class="line">+----------------+------------+</span><br><span class="line">| Bird seed      |      10.00 |</span><br><span class="line">| Carrots        |       2.50 |</span><br><span class="line">| Detonator      |      13.00 |</span><br><span class="line">| Fuses          |       3.42 |</span><br><span class="line">| Oil can        |       8.99 |</span><br><span class="line">| Safe           |      50.00 |</span><br><span class="line">| Sling          |       4.49 |</span><br><span class="line">| TNT (1 stick)  |       2.50 |</span><br><span class="line">| TNT (5 sticks) |      10.00 |</span><br><span class="line">+----------------+------------+</span><br><span class="line">9 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>使用IN操作符可以代替OR操作符的功能，且较为方便便捷。</p>
<p>例如上述代码，使用以下含OR的代码一样可以完成操作，但是使用IN更加清除直观，且次序较容易管理，比OR操作符执行速度要快。</p>
<h4 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h4><p>WHERE子句中的NOT操作符只有一个功能，即否定之后的所有关键字。</p>
<blockquote>
<p><strong>MySQL中的NOT</strong> MySQL支持使用NOT 对IN 、BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</p>
</blockquote>
<p>使用语句：<code>SELECT prod_name, vend_id, prod_price FROM products WHERE vend_id NOT IN (1002, 1003) AND prod_price NOT BETWEEN 5 AND 10;</code></p>
<p>此语句中：使用NOT对1002和1003编号进行反选，且除去价格5到10之间的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name, vend_id, prod_price FROM products WHERE vend_id NOT IN (1002, 1003) AND prod_price NOT BETWEEN 5 AND 10;</span><br><span class="line">+--------------+---------+------------+</span><br><span class="line">| prod_name    | vend_id | prod_price |</span><br><span class="line">+--------------+---------+------------+</span><br><span class="line">| 2 ton anvil  |    1001 |      14.99 |</span><br><span class="line">| JetPack 1000 |    1005 |      35.00 |</span><br><span class="line">| JetPack 2000 |    1005 |      55.00 |</span><br><span class="line">+--------------+---------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h3><p>前面介绍的所有操作符都是针对已知值进行过滤的。不管是匹配一个还是多个值，测试大于还是小于已知值，或者检查某个范围的值，共同点是过滤中使用的值都是已知的。但是，这种过滤方法并不是任何时候都好用。例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。利用通配符可创建比较特定数据的搜索模式。在这个例子中，如果你想找出名称包含anvil的所有产品，可构造一个通配符搜索模式，找出产品名中任何位置出现anvil的产品。</p>
<h4 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号(%)通配符"></a>百分号(%)通配符</h4><p>使用<code>%</code>可以表示任何字符出现任意次数，例如为了找出jet开头的产品，可以使用jet%进行匹配。</p>
<p>使用语句：<code>SELECT prod_id, prod_name From products WHERE prod_name LIKE &#39;jet%&#39;;</code></p>
<p>此语句中：使用jet%进行了匹配，jet和JET都可以进行匹配，数据库若不特殊配置，不区分大小写，若配置后，jet%与JetPACK会不匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_name From products WHERE prod_name LIKE &#x27;jet%&#x27;;</span><br><span class="line">+---------+--------------+</span><br><span class="line">| prod_id | prod_name    |</span><br><span class="line">+---------+--------------+</span><br><span class="line">| JP1000  | JetPack 1000 |</span><br><span class="line">| JP2000  | JetPack 2000 |</span><br><span class="line">+---------+--------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>若想要查询含有某个词的行，可以前后都带上%，例如<code>%anvil%</code>，这个可以匹配任何位置包含anvil的文本，不论前后出现过什么字符。</strong></p>
<p><strong>通配符也可以出现在搜索模式之间，例如<code>s%e</code>可以找出以s开头和以e结尾的字符，且%代表0个，1个或多个字符，意味着其也可以匹配se。</strong></p>
<blockquote>
<p><strong>注意尾空格</strong> 尾空格可能会干扰通配符匹配。例如，在保存词anvil 时， 如果它后面有一个或多个空格， 则子句WHEREprod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数去掉首尾空格。</p>
</blockquote>
<blockquote>
<p><strong>注意NULL</strong> 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</p>
</blockquote>
<h4 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线(_)通配符"></a>下划线(_)通配符</h4><p>该通配符可以匹配单个字符，不能和%一样去匹配多个字符或0个字符，必须要恰好为1个。</p>
<p>例如，使用LIKE ‘_ ton anvil’，可以匹配例如’1 ton anvil’但是不能匹配’.1 ton anvil’</p>
<h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。即先把范围缩小后，再使用通配符进行查询</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ol>
<h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><p>正则表达式用正则表达式语言来建立，正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言。与任意语言一样，正则表达式具有你必须学习的特殊的语法和指令。</p>
<blockquote>
<p>注意，MySQL中的正则表达式仅为正则表达式的一个子集，意味着有些语句会受到限制。</p>
</blockquote>
<h4 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h4><p>使用REGEXP(Regular Expression)关键字去进行匹配，后面所跟的东西叫做正则表达式。</p>
<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;.000&#39; ORDER BY prod_name;</code></p>
<p>此语句中：使用了正则表达式 <code>.000</code>代替了1000和2000等数据，即.匹配了任意一个字符，因此将1000和2000全部匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;.000&#x27; ORDER BY prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">+--------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用LIKE和REGEXP有区别，LIKE不会匹配列值，若被匹配的文本在列值中出现，LIKE将无法找到，但是REGEXP可以找到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name LIKE &#x27;1 TON&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name LIKE &#x27;1 TON%&#x27;;</span><br><span class="line">+-------------+</span><br><span class="line">| prod_name   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1 ton anvil |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;1 TON&#x27;;</span><br><span class="line">+-------------+</span><br><span class="line">| prod_name   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1 ton anvil |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p><strong>匹配不区分大小写</strong> MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXPBINARY ‘JetPack .000’。</p>
</blockquote>
<h4 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h4><p>使用|进行或匹配，例如 <code>REGEXP &#39;1000|2000|3000&#39;</code>，将匹配1000或2000或3000，因此将会把所有的匹配数据全部返回。</p>
<h4 id="匹配特定字符"><a href="#匹配特定字符" class="headerlink" title="匹配特定字符"></a>匹配特定字符</h4><p>可以使用<code>[]</code>对特定的一组字符进行匹配，例如使用’REGEXP [123] TON’，将会匹配1或2或3 TON</p>
<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;[123] TON&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;[123] TON&#x27;;</span><br><span class="line">+-------------+</span><br><span class="line">| prod_name   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1 ton anvil |</span><br><span class="line">| 2 ton anvil |</span><br><span class="line">+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>所以，[] 像是另一种OR语句，。事实上，正则表达式[123] Ton为[1|2|3] Ton的缩写，也可以使用后者。但是，需要用[]来定义OR语句查找什么。</p>
<p>若不使用[]则会导致查找出错，例如使用 <code>1|2|3 TON</code> ，MySQL会假定你的意思是’1’或’2’或’3 ton’。</p>
<blockquote>
<p>在前面加上^可以取反，例如[ ^123]可以匹配除了123以外的任何东西</p>
</blockquote>
<h4 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h4><p>[0123456789]可以用来匹配数字0-9，但是若字符较多会比较麻烦，因此可以使用[0-9]来匹配0-9</p>
<p>范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。</p>
<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;[0-5] TON&#39; ORDER BY prod_name;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;[0-5] TON&#x27; ORDER BY prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h4><p>正则表达式中包含了特殊字符，例如：. [] | - 等特殊字符，那么若想查询此类特殊字符，应该怎么办？</p>
<p>答案是可以使用<code>\\</code>作为前导，\- 表示查找 -， \. 表示查找 .</p>
<p>使用语句：<code>SELECT vend_name FROM vendors WHERE vend_name REGEXP &#39;\\.&#39; ORDER BY vend_name;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name FROM vendors WHERE vend_name REGEXP &#x27;\\.&#x27; ORDER BY vend_name;</span><br><span class="line">+--------------+</span><br><span class="line">| vend_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| Furball Inc. |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>除此之外，\也可以用来引用元字符，例如：<br>| 元字符 | 说明  |<br>| —– | ——– |<br>| \\f | 换页     |<br>| \\n | 换行     |<br>| \\r | 回车     |<br>| \\t | 制表     |<br>| \\v | 纵向制表 |</p>
<blockquote>
<p>为了匹配反斜杠本身，需要使用 <code>\\\</code> 进行匹配。</p>
</blockquote>
<blockquote>
<p><strong>\或\\?</strong> 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。</p>
</blockquote>
<h4 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h4><p>为了更方便地找出经常使用的数字，字母或者数字字母字符等，可以适用预定的字符集。称为字符类(character class)</p>
<p>字符类如下表所示：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字符（同[a-zA-Z]）</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符（ASCII 0到31和127）</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意小写字母（同[a-z]）</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任意十六进制数字（同[a-fA-F0-9]）</td>
</tr>
</tbody></table>
<h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><p>可以使用重复元字符进行多个匹配，例如找出所有的数而不管一共有多少位，或者想查询一个单词但是满足单词后可能接上了尾缀s。</p>
<p>重复元字符如下表：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（等于{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody></table>
<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;\\([0-9] sticks?\\)&#39;;</code></p>
<p>此语句中：\\() 匹配了括号，sticks? 匹配 stick或者sticks，?表示前一个字符出现1次或者0次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;\\([0-9] sticks?\\)&#x27;;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_name      |</span><br><span class="line">+----------------+</span><br><span class="line">| TNT (1 stick)  |</span><br><span class="line">| TNT (5 sticks) |</span><br><span class="line">+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;[[:digit:]]&#123;4&#125;&#39; ORDER BY prod_name;</code></p>
<p>此语句中：，[:digit:]匹配任意数字，因而它为数字的一个集合。{4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;[[:digit:]]&#123;4&#125;&#x27; ORDER BY prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| JetPack 1000 |</span><br><span class="line">| JetPack 2000 |</span><br><span class="line">+--------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>目前为止的所有例子都是为了匹配一个串中任意位置的文本，为了匹配特定位置的文本，需要使用定位符。</p>
<p>定位符如下所示：</p>
<table>
<thead>
<tr>
<th>元 字 符</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody></table>
<p>若想搜索一个以数或者小数点开头的所有产品，应该怎么使用？如果简单的搜索[0-9\\.]肯定不行，因为他会在文本内任意匹配而不是在开头匹配。</p>
<p>使用语句：<code>SELECT prod_name FROM products WHERE prod_name REGEXP &#39;^[0-9\\.]&#39; ORDER BY prod_name;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &#x27;^[0-9\\.]&#x27; ORDER BY prod_name;</span><br><span class="line">+--------------+</span><br><span class="line">| prod_name    |</span><br><span class="line">+--------------+</span><br><span class="line">| .5 ton anvil |</span><br><span class="line">| 1 ton anvil  |</span><br><span class="line">| 2 ton anvil  |</span><br><span class="line">+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>^的双重用途</strong> ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。</p>
</blockquote>
<blockquote>
<p><strong>使REGEXP起类似LIKE的作用</strong> LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。</p>
</blockquote>
<blockquote>
<p>简单的正则表达式测试 可以在不使用数据库表的情况下用SELECT来测试正则表达式。REGEXP检查总是返回0（没有匹配）或1（匹配）。可以用带文字串的REGEXP来测试表达式，并试验它们。相应的语法如下：</p>
<p>SELECT ‘hello’ REGEXP ‘[0-9]’;</p>
<p>这个例子显然将返回0（因为文本hello中没有数字）。</p>
</blockquote>
<h3 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h3><p>存储在表中的数据不都是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据，然后再在客户机应用程序或报告程序中重新格式化。</p>
<blockquote>
<p><strong>字段</strong> 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p>
</blockquote>
<blockquote>
<p><strong>客户机与服务器的格式</strong> 可在SQL语句内完成的许多转换和格式化工作都可以直接在客户机应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在客户机中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。</p>
</blockquote>
<h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>vendors表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。</p>
<blockquote>
<p><strong>拼接（concatenate）</strong> 将值联结到一起构成单个值。</p>
</blockquote>
<p>解决方案是把两个列直接拼接起来，在MySQL的SELECT语句中，可以使用<code>Concat()</code>函数来拼接两个列。</p>
<p>使用语句：<code>SELECT Concat(vend_name, &#39;(&#39;, vend_country, &#39;)&#39;) FROM vendors ORDER BY vend_name;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT Concat(vend_name, &#x27;(&#x27;, vend_country, &#x27;)&#x27;) FROM vendors ORDER BY vend_name;</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| Concat(vend_name, &#x27;(&#x27;, vend_country, &#x27;)&#x27;) |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| ACME(USA)                                 |</span><br><span class="line">| Anvils R Us(USA)                          |</span><br><span class="line">| Furball Inc.(USA)                         |</span><br><span class="line">| Jet Set(England)                          |</span><br><span class="line">| Jouets Et Ours(France)                    |</span><br><span class="line">| LT Supplies(USA)                          |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>Concat()需要一个或多个指定的串，各个串之间用逗号分隔。上面的SELECT语句连接以下4个元素：</p>
<ul>
<li>存储在vend_name列中的名字；</li>
<li>包含一个空格和一个左圆括号的串；</li>
<li>存储在vend_country列中的国家；</li>
<li>包含一个右圆括号的串。</li>
</ul>
<h5 id="Trim函数"><a href="#Trim函数" class="headerlink" title="Trim函数"></a>Trim函数</h5><blockquote>
<p><strong>Trim函数</strong> 该函数可以将值的左右两侧空格全部去掉，使用RTrim可以去掉右侧的空格，使用LTrim可以去掉左侧的空格</p>
</blockquote>
<p>例如使用语句：<code>SELECT Concat(Trim(vend_name), &#39;(&#39;, Trim(vend_country), &#39;)&#39;) FROM vendors ORDER BY vend_name;</code></p>
<h5 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h5><p>SELECT语句拼接地址字段工作得很好，但是新计算列的名字实际上没有，只是一个值，而一个未知的值不能用在客户机应用中，因为其没有办法被引用，因此我们使用AS语句，为其赋予一个替换名(别名：alias)。</p>
<p>使用语句：<code>SELECT Concat(Trim(vend_name), &#39;(&#39;, Trim(vend_country), &#39;)&#39;) AS vend_title FROM vendors ORDER BY vend_name;</code></p>
<p>此语句中：可以看到返回的列名为vend_title，所有的客户机都可以直接使用，就像一个实际的列表一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT Concat(Trim(vend_name), &#x27;(&#x27;, Trim(vend_country), &#x27;)&#x27;) AS vend_title FROM vendors ORDER BY vend_name;</span><br><span class="line">+------------------------+</span><br><span class="line">| vend_title             |</span><br><span class="line">+------------------------+</span><br><span class="line">| ACME(USA)              |</span><br><span class="line">| Anvils R Us(USA)       |</span><br><span class="line">| Furball Inc.(USA)      |</span><br><span class="line">| Jet Set(England)       |</span><br><span class="line">| Jouets Et Ours(France) |</span><br><span class="line">| LT Supplies(USA)       |</span><br><span class="line">+------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>导出列</strong> 别名有时也称为导出列（derived column），不管称为什么，它们所代表的都是相同的东西。</p>
</blockquote>
<blockquote>
<p><strong>别名的其他用途</strong> 别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它，等等。</p>
</blockquote>
<h4 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h4><p>在使用SELECT语句中，可能会出现需要进行算数运算的情况，例如，知道物品单价和物品数量，想知道总价格，应该将单价与数量相乘。显然在知道了单价和数量后，没有必要将总价格进行储存，这将占很大的空间。</p>
<p>所以我们可以使用算数运算，进行统计。</p>
<p>使用语句：<code>SELECT prod_id, quantity, item_price, quantity * item_price AS total_price FROM orderitems WHERE order_num = 20005;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, quantity, item_price, quantity * item_price AS total_price FROM orderitems WHERE order_num = 20005;</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| prod_id | quantity | item_price | total_price |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| ANV01   |       10 |       5.99 |       59.90 |</span><br><span class="line">| ANV02   |        3 |       9.99 |       29.97 |</span><br><span class="line">| TNT2    |        5 |      10.00 |       50.00 |</span><br><span class="line">| FB      |        1 |      10.00 |       10.00 |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>除此之外，还允许使用+，-，*，/操作符。</strong></p>
<h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><p>大多数SQL支持以下类型的函数：</p>
<ul>
<li>用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。</li>
<li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。</li>
<li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。</li>
<li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。</li>
</ul>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody></table>
<p>其中，Soundex()函数可以匹配读音相同的串，例如Soundex(‘Y.Lie’) = Soundex(‘Y LEE’)的返回值为TRUE；</p>
<p>使用语句：<code>mysql&gt; SELECT Upper(Trim(SubString(prod_desc, Length(prod_desc) - 4, 5))) AS temp FROM products;</code></p>
<p>此语句中：使用了Substring函数，用法为：SubString(buffer, offset, len);注意此处的offset从1开始到Length(buffer)结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT Upper(Trim(SubString(prod_desc, Length(prod_desc) - 4, 5))) AS temp FROM products;</span><br><span class="line">+-------+</span><br><span class="line">| temp  |</span><br><span class="line">+-------+</span><br><span class="line">| HOOK  |</span><br><span class="line">| CASE  |</span><br><span class="line">| CASE  |</span><br><span class="line">| LUDED |</span><br><span class="line">| NERS) |</span><br><span class="line">| ONLY) |</span><br><span class="line">| LONG  |</span><br><span class="line">| E USE |</span><br><span class="line">| I-USE |</span><br><span class="line">| , RED |</span><br><span class="line">| LOCK  |</span><br><span class="line">| S ALL |</span><br><span class="line">| STICK |</span><br><span class="line">| TICKS |</span><br><span class="line">+-------+</span><br><span class="line">14 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前date</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前time</td>
</tr>
<tr>
<td>Date()</td>
<td>返回date time的date部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个date之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个date，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前date和time</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<p>MySQL使用的日期格式无论什么时候都要使用yyyy-mm-dd。因此2021年5月1日，为2021-05-01。其他的方法也许也可以，但是这样可以排除多义性。</p>
<blockquote>
<p><strong>应该总是使用4位数字的年份</strong> 支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定。</p>
</blockquote>
<p>使用语句：<code>SELECT cust_id, order_num, order_date, DateDiff(CurDate(), Date(order_date)) AS diff FROM orders WHERE Month(order_date) = &#39;10&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, order_num, order_date, DateDiff(CurDate(), Date(order_date)) AS diff FROM orders WHERE Month(order_date) = &#x27;10&#x27;;</span><br><span class="line">+---------+-----------+---------------------+------+</span><br><span class="line">| cust_id | order_num | order_date          | diff |</span><br><span class="line">+---------+-----------+---------------------+------+</span><br><span class="line">|   10005 |     20008 | 2005-10-03 00:00:00 | 5822 |</span><br><span class="line">|   10001 |     20009 | 2005-10-08 00:00:00 | 5817 |</span><br><span class="line">+---------+-----------+---------------------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>注意，sql中，星期天是1，星期一是2，……星期六是7</strong></p>
<p>若需要检测一个范围，则可以使用BETWEEN操作符。</p>
<p>使用语句：<code>SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-09-30&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-09-30&#x27;;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h3 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h3><p>我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种。</p>
<ul>
<li>确定表中行数（或者满足某个条件或包含某个特定值的行数）。</li>
<li>获得表中行组的和。</li>
<li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li>
</ul>
<h4 id="汇总函数的使用"><a href="#汇总函数的使用" class="headerlink" title="汇总函数的使用"></a>汇总函数的使用</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<h5 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h5><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。</p>
<p>使用语句：<code>SELECT AVG(prod_price) AS avg_price FROM products;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(prod_price) AS avg_price FROM products;</span><br><span class="line">+-----------+</span><br><span class="line">| avg_price |</span><br><span class="line">+-----------+</span><br><span class="line">| 16.133571 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>只用于单个列</strong> AVG()只能用来确定特定数值列的平均值，而<br>且列名必须作为函数参数给出。为了获得多个列的平均值，<br>必须使用多个AVG()函数。</p>
</blockquote>
<blockquote>
<p><strong>NULL值</strong> AVG()函数忽略列值为NULL的行。</p>
</blockquote>
<h5 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h5><p>该COUNT()函数共有两种使用方式：</p>
<ul>
<li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li>
<li>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<p>使用语句：<code>SELECT COUNT(*) AS num_cust FROM customers;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) AS num_cust FROM customers;</span><br><span class="line">+----------+</span><br><span class="line">| num_cust |</span><br><span class="line">+----------+</span><br><span class="line">|        5 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>使用语句：<code>SELECT COUNT(cust_email) AS num_cust FROM customers;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(cust_email) AS num_cust FROM customers;</span><br><span class="line">+----------+</span><br><span class="line">| num_cust |</span><br><span class="line">+----------+</span><br><span class="line">|        3 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NULL值</strong> 如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号（*），则不忽略。</p>
</blockquote>
<h5 id="MAX-MIN"><a href="#MAX-MIN" class="headerlink" title="MAX(), MIN()"></a>MAX(), MIN()</h5><p>使用MAX()函数需要指定列名。</p>
<p>使用语句：<code>SELECT MAX(prod_price) AS max_price, MIN(prod_price) AS min_price FROM products;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT MAX(prod_price) AS max_price, MIN(prod_price) AS min_price FROM products;</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| max_price | min_price |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">|     55.00 |      2.50 |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>对非数值数据使用MAX()</strong> 虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。</p>
</blockquote>
<h5 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h5><p>使用语句<code>SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;</span><br><span class="line">+---------------+</span><br><span class="line">| items_ordered |</span><br><span class="line">+---------------+</span><br><span class="line">|            19 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>SUM()也可以用来计算合计值。例如算总金额</p>
<p>使用语句<code>SELECT SUM(quantity * item_price) AS total_price FROM orderitems WHERE order_num = 20005;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(quantity * item_price) AS total_price FROM orderitems WHERE order_num = 20005;</span><br><span class="line">+-------------+</span><br><span class="line">| total_price |</span><br><span class="line">+-------------+</span><br><span class="line">|      149.87 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h4><p>使用聚集函数的DISTINCT参数。对于上述的五个聚集函数(SUM, COUNT, MAX, MIN, AVG)，都可以使用DISTINCT参数。</p>
<p>例如在使用AVG()函数返回特定供应商提供的产品的平均价格。如果不使用DISTINCT参数，平均值将考虑所有的价格，也就是所有相同的值都会被计算一遍，若想要进行多个相同值的值只被计算一次，则需要加入DISTINCT参数。</p>
<p>使用语句：<code>SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003;</span><br><span class="line">+-----------+</span><br><span class="line">| avg_price |</span><br><span class="line">+-----------+</span><br><span class="line">| 15.998000 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，在使用了DISTINCT后，此例子中的avg_price比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p>
<blockquote>
<p><strong>注意</strong>  如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</p>
</blockquote>
<blockquote>
<p><strong>将DISTINCT用于MIN()和MAX()</strong> 虽然DISTINCT从技术上可<br>用于MIN()和MAX()，但这样做实际上没有价值。一个列中的<br>最小值和最大值不管是否包含不同值都是相同的。</p>
</blockquote>
<h4 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h4><p>目前的所有聚集函数都只涉及了单个的函数，但是实际上SELECT语句可能包括了多个聚集函数。</p>
<p>使用语句：<code>SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg FROM products;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avg FROM products;</span><br><span class="line">+-----------+-----------+-----------+-----------+</span><br><span class="line">| num_items | price_min | price_max | price_avg |</span><br><span class="line">+-----------+-----------+-----------+-----------+</span><br><span class="line">|        14 |      2.50 |     55.00 | 16.133571 |</span><br><span class="line">+-----------+-----------+-----------+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><p>SQL聚集函数可以用来汇总数据，这使得我们能够对数据进行计数，计算和平均数，获得最大值，最小值。</p>
<p>目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。但如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？</p>
<p>这就需要分组来方便聚集计算，分组允许把数据分为多个逻辑组，对每个组进行聚集计算。</p>
<h4 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h4><p>使用语句：<code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;</code></p>
<p>此语句中：使用了SELECT语句指定了两个列，vend_id包含产品供应商的ID，num_prods为计算字段（用COUNT(*)函数建立）。GROUP BY子句指示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|    1001 |         3 |</span><br><span class="line">|    1002 |         2 |</span><br><span class="line">|    1003 |         7 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>在具体使用GROUP BY子句前，需要知道一些重要的规定。</p>
<ul>
<li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li>
<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<blockquote>
<p><strong>使用ROLLUP</strong> 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</p>
</blockquote>
<h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><p>除了能够使用GROUP BY分组之外，还允许过滤分组，允许过滤那些分组或者排除那些分组。例如，需要列出两个订单的所有顾客。为了得出需要的数据，必须基于完整的分组而不是个别的行进行过滤。</p>
<p>MYSQL为此目的提供了另外的子句，就是HAVING子句。该子非常类似于WHERE，事实上所有的类型的WHERE子句都可以使用HAVING来进行替代。唯一的区别是，WHERE过滤行HAVING过滤分组。</p>
<p>使用语句：<code>SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</code></p>
<p>此语句中：最后一行增加了HAVING子句，它过滤COUNT(*) &gt;=2（两个以上的订单）的那些分组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</span><br><span class="line">+---------+--------+</span><br><span class="line">| cust_id | orders |</span><br><span class="line">+---------+--------+</span><br><span class="line">|   10001 |      2 |</span><br><span class="line">+---------+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。</p>
<p>使用语句：<code>SELECT cust_id, COUNT(*) AS total_count FROM orders WHERE DATE(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-12-31&#39; GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id, COUNT(*) AS total_count FROM orders WHERE DATE(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-12-31&#x27; GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| cust_id | total_count |</span><br><span class="line">+---------+-------------+</span><br><span class="line">|   10001 |           2 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>注意，需要先使用WHERE再使用GROUP BY子句。</p>
<p>使用语句：<code>SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*) &gt;= 2;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*) &gt;= 2;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| vend_id | num_prods |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|    1003 |         4 |</span><br><span class="line">|    1005 |         2 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h4><p>GROUP BY和 ORDER BY存在一些区别，也能完成某些相同的工作。</p>
<p>区别有：</p>
<table>
<thead>
<tr>
<th>ORDER BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody><tr>
<td>排序产生的输出</td>
<td>分组行。但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意列都可以使用（甚至非选择的列也可以使用）</td>
<td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果与聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意！</strong> 千万不要忘记再使用GROUP BY子句时，也应该给出ORDER BY子句，这是保证排序的唯一可行方法。不能依赖GROUP BY所提供的排序顺序。</p>
</blockquote>
<p>使用语句：<code>SELECT order_num, SUM(quantity*item_price) AS noOrderTotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price) &gt;= 50;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT order_num, SUM(quantity*item_price) AS noOrderTotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price) &gt;= 50;</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| order_num | noOrderTotal |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">|     20005 |       149.87 |</span><br><span class="line">|     20006 |        55.00 |</span><br><span class="line">|     20007 |      1000.00 |</span><br><span class="line">|     20008 |       125.00 |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line">-- 可以看到未进行排序</span><br></pre></td></tr></table></figure>

<p>使用语句：<code>SELECT order_num, SUM(quantity*item_price) AS orderTotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price) &gt;= 50 ORDER BY orderTotal;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT order_num, SUM(quantity*item_price) AS orderTotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price) &gt;= 50 ORDER BY orderTotal;</span><br><span class="line">+-----------+------------+</span><br><span class="line">| order_num | orderTotal |</span><br><span class="line">+-----------+------------+</span><br><span class="line">|     20006 |      55.00 |</span><br><span class="line">|     20008 |     125.00 |</span><br><span class="line">|     20005 |     149.87 |</span><br><span class="line">|     20007 |    1000.00 |</span><br><span class="line">+-----------+------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="SELECT子句的顺序"><a href="#SELECT子句的顺序" class="headerlink" title="SELECT子句的顺序"></a>SELECT子句的顺序</h4><table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或者表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从什么表中检索数据</td>
<td>仅在从表选BY择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序的顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote>
<p>MySQL 4.1引入了对子查询的支持，所以要想使用这些SQL，必须使用MySQL4.1或更高级的版本。</p>
</blockquote>
<p>SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询。</p>
<h4 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h4><p>提供的样例数据库中，订单存储在两个表中。orders表存储包含订单号、客户ID、订单日期的订单作为一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息，它只存储客户的ID。实际的客户信息存储在customers表中。</p>
<p>现在，假设需要列出订购物品TNT2的所有客户，应该如何检索？</p>
<p>步骤：<br>(1) 检索包含物品TNT2的所有订单的编号。<br>(2) 检索具有前一步骤列出的订单编号的所有客户的ID。<br>(3) 检索前一步骤返回的所有客户ID的客户信息。</p>
<p>上述的所有步骤都可以作为一个单独的查询来执行，因此，可以把一条SELECT的查询返回值作为下一条SELECT语句的WHERE子句。</p>
<p>第一步：<code>SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT order_num FROM orderitems WHERE prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">+-----------+</span><br><span class="line">| order_num |</span><br><span class="line">+-----------+</span><br><span class="line">|     20005 |</span><br><span class="line">|     20007 |</span><br><span class="line">+-----------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>将上一个查询得到的order_num，20005，20007作为下面的入参进行查询</p>
<p>第二步：<code>SELECT cust_id FROM orders WHERE order_num IN (20005, 20007);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_id FROM orders WHERE order_num IN (20005, 20007);</span><br><span class="line">+---------+</span><br><span class="line">| cust_id |</span><br><span class="line">+---------+</span><br><span class="line">|   10001 |</span><br><span class="line">|   10004 |</span><br><span class="line">+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>若使用子查询，则为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id </span><br><span class="line">FROM orders </span><br><span class="line">WHERE order_num IN (SELECT order_num </span><br><span class="line">                    FROM orderitems </span><br><span class="line">                    WHERE prod_id = &#x27;TNT2&#x27;);         </span><br><span class="line">-- 结果</span><br><span class="line">+---------+</span><br><span class="line">| cust_id |</span><br><span class="line">+---------+</span><br><span class="line">|   10001 |</span><br><span class="line">|   10004 |</span><br><span class="line">+---------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>第三步：<code>SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001, 10004);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001, 10004);</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>若联合上述所有查询作为子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_id IN (SELECT cust_id </span><br><span class="line">				  FROM orders </span><br><span class="line">				  WHERE order_num IN (SELECT order_num </span><br><span class="line">                    				  FROM orderitems </span><br><span class="line">                    				  WHERE prod_id = &#x27;TNT2&#x27;));</span><br><span class="line">-- 结果           				  </span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">2 rows in set (0.01 sec)                    				  </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>列必须匹配</strong> 在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</p>
</blockquote>
<h4 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h4><p>使用子查询的另一方法是创建计算字段。假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。</p>
<p>步骤如下：<br>(1) 从customers表中检索客户列表。<br>(2) 对于检索出的每个客户，统计其在orders表中的订单数目。</p>
<p>步骤一：<code>SELECT COUNT(*) AS orders FROM orders WHERE cust_id = 10001;</code></p>
<p>索引cust_id = 10001的用户的订单次数</p>
<p>步骤二：将10001替换成顾客表的数据，将两个表联系起来；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_state, (SELECT COUNT(*) </span><br><span class="line">                               FROM orders </span><br><span class="line">                               WHERE orders.cust_id = customers.cust_id) AS orders</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY orders DESC;</span><br><span class="line">-- 结果</span><br><span class="line">+----------------+------------+--------+</span><br><span class="line">| cust_name      | cust_state | orders |</span><br><span class="line">+----------------+------------+--------+</span><br><span class="line">| Coyote Inc.    | MI         |      2 |</span><br><span class="line">| Wascals        | IN         |      1 |</span><br><span class="line">| Yosemite Place | AZ         |      1 |</span><br><span class="line">| E Fudd         | IL         |      1 |</span><br><span class="line">| Mouse House    | OH         |      0 |</span><br><span class="line">+----------------+------------+--------+</span><br><span class="line">5 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><h4 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h4><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。</p>
<h5 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h5><p>什么是关系表？</p>
<p>假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。</p>
<p>现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？<code>将这些数据与产品信息分开存储</code>的理由如下。</p>
<ul>
<li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li>
<li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li>
<li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li>
</ul>
<p>各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p>
<p>在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（primary key），可以是供应商ID或任何其他唯一值。</p>
<p><strong>products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</strong></p>
<blockquote>
<p><strong>外键（foreign key）</strong> 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>这样做的好处如下：</p>
<ul>
<li>供应商信息不重复，从而不浪费时间和空间；</li>
<li>如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；</li>
<li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li>
</ul>
</blockquote>
<h5 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h5><p>正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。</p>
<p>如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？</p>
<p>答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<blockquote>
<p><strong>维护引用完整性</strong> 重要的是，要理解联结不是物理实体。换句话说，它在实际的数据库表中不存在。联结由MySQL根据需<br>要建立，它存在于查询的执行当中。</p>
<p>在使用关系表时，仅在关系列中插入合法的数据非常重要。回到这里的例子，如果在products表中插入拥有非法供应商ID（即没有在vendors表中出现）的供应商生产的产品，则这些<br>产品是不可访问的，因为它们没有关联到某个供应商。</p>
<p>为防止这种情况发生，可指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。这就是维护引用完整性，它是通过在表的定义中指定主键和外键来实现的。</p>
</blockquote>
<h4 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h4><p>很容易创建联结，只需要规定所有的表如何关联即可。</p>
<p>使用语句：<code>SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name;</code></p>
<p>此语句中：最大的差别是所指定的两个列（prod_name和prod_price）在一个表中，而另一个列（vend_name）在另一个表中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name;</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">14 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>完全限定列名</strong> 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。</p>
</blockquote>
<h5 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h5><p>在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p>
<blockquote>
<p><strong>笛卡儿积（cartesian product）</strong> 由<strong>没有联结条件</strong>的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
</blockquote>
<h5 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h5><p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。</p>
<p>使用语句：<code>SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;</code></p>
<p>此语句中：SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>将返回相同的结果。</p>
<blockquote>
<p><strong>使用哪种语法?</strong> ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>
</blockquote>
<h5 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h5><p>SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, vend_name, prod_price, quantity </span><br><span class="line">FROM orderitems, products, vendors </span><br><span class="line">WHERE products.vend_id = vendors.vend_id</span><br><span class="line">  AND orderitems.prod_id = products.prod_id </span><br><span class="line">  AND order_num = 20005;</span><br><span class="line">  </span><br><span class="line">-- result</span><br><span class="line">+----------------+-------------+------------+----------+</span><br><span class="line">| prod_name      | vend_name   | prod_price | quantity |</span><br><span class="line">+----------------+-------------+------------+----------+</span><br><span class="line">| .5 ton anvil   | Anvils R Us |       5.99 |       10 |</span><br><span class="line">| 1 ton anvil    | Anvils R Us |       9.99 |        3 |</span><br><span class="line">| TNT (5 sticks) | ACME        |      10.00 |        5 |</span><br><span class="line">| Bird seed      | ACME        |      10.00 |        1 |</span><br><span class="line">+----------------+-------------+------------+----------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>因此，有时候使用子查询并不一定是最优解，例如3.11中的子查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_id IN (SELECT cust_id </span><br><span class="line">				  FROM orders </span><br><span class="line">				  WHERE order_num IN (SELECT order_num </span><br><span class="line">                    				  FROM orderitems </span><br><span class="line">                    				  WHERE prod_id = &#x27;TNT2&#x27;));</span><br><span class="line">-- 结果           				  </span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br><span class="line"></span><br><span class="line">-- 可以替换成</span><br><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">  AND orderitems.order_num = orders.order_num</span><br><span class="line">  AND prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">  </span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由：</p>
<ul>
<li><p>缩短SQL语句；</p>
</li>
<li><p>允许在单条SELECT语句中多次使用相同的表。</p>
</li>
</ul>
<p>例如3.12.2.3中的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">  AND orderitems.order_num = orders.order_num</span><br><span class="line">  AND prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">-- 可以对表名取别名</span><br><span class="line"></span><br><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">  AND oi.order_num = o.order_num</span><br><span class="line">  AND prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">  </span><br><span class="line">-- SQL语句显著缩短</span><br><span class="line">-- result</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</strong></p>
<h4 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h4><p>迄今为止，我们使用的只是称为内部联结或等值联结（equijoin）的简单联结。还存在其他三种联结，即自联结，自然联结和外部联结。</p>
<h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><p>如前所述，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表。</p>
<p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的所有物品。</p>
<p>可以使用以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE vend_id = (SELECT vend_id </span><br><span class="line">                 FROM products</span><br><span class="line">                 WHERE prod_id = &#x27;DTNTR&#x27;);</span><br><span class="line">-- result</span><br><span class="line">+---------+----------------+</span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+---------+----------------+</span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+---------+----------------+</span><br></pre></td></tr></table></figure>

<p>若使用联结进行查询，可以使用如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name </span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id  = p2.vend_id</span><br><span class="line">  AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>用自联结而不用子查询</strong> 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p>
</blockquote>
<h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<p>一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity,       		 oi.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">  AND oi.order_num = o.order_num</span><br><span class="line">  AND prod_id = &#x27;FB&#x27;;</span><br></pre></td></tr></table></figure>

<p>此语句中：通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p>
<h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作：</p>
<ul>
<li><p>对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户；</p>
</li>
<li><p>列出所有产品和订购数量，包括没有人订购的产品；</p>
</li>
<li><p>计算平均销售规模，包括那些至今尚未下订单的客户。</p>
</li>
</ul>
<p>在上述例子中，联结包含了那些在相关表中没有关联行的行。这种类型的联结称为<code>外部联结</code>。</p>
<p>若想检索所有客户和订单，可以使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">  ON customers.cust_id = orders.cust_id;</span><br><span class="line">-- result</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure>

<p>但是此时未下订单的用户并没有被检索出，若想检索出，可以使用 OUTER JOIN 来指定联结的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">  ON customers.cust_id = orders.cust_id;</span><br><span class="line">-- result</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10002 |      NULL |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure>

<p>这条SELECT语句使用了关键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所<br>有行，应该使用RIGHT OUTER JOIN，如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers RIGHT OUTER JOIN orders</span><br><span class="line">  ON customers.cust_id = orders.cust_id;</span><br><span class="line">-- result</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h4><p>如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.cust_name, c.cust_id, COUNT(o.order_num) AS num_ord</span><br><span class="line">FROM customers AS c INNER JOIN orders AS o </span><br><span class="line">  ON c.cust_id = o.cust_id </span><br><span class="line">GROUP BY c.cust_id;</span><br><span class="line">-- result</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| cust_name      | cust_id | num_ord |</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| Coyote Inc.    |   10001 |       2 |</span><br><span class="line">| Wascals        |   10003 |       1 |</span><br><span class="line">| Yosemite Place |   10004 |       1 |</span><br><span class="line">| E Fudd         |   10005 |       1 |</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>同样也可以与其他不同类型的联结一并使用。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.cust_name, c.cust_id, COUNT(o.order_num) AS num_ord</span><br><span class="line">FROM customers AS c LEFT OUTER JOIN orders AS o </span><br><span class="line">  ON c.cust_id = o.cust_id </span><br><span class="line">GROUP BY c.cust_id</span><br><span class="line">ORDER BY num_ord DESC;</span><br><span class="line">-- result</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| cust_name      | cust_id | num_ord |</span><br><span class="line">+----------------+---------+---------+</span><br><span class="line">| Coyote Inc.    |   10001 |       2 |</span><br><span class="line">| Wascals        |   10003 |       1 |</span><br><span class="line">| Yosemite Place |   10004 |       1 |</span><br><span class="line">| E Fudd         |   10005 |       1 |</span><br><span class="line">| Mouse House    |   10002 |       0 |</span><br><span class="line">+----------------+---------+---------+</span><br></pre></td></tr></table></figure>

<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<h4 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h4><p>可以使用UNION操作符来组合数条SQL查询语句，利用UNION，可以给出多条SELECT 语句，将他们的结果组合成单个的结果集</p>
<h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><p>UNION的使用非常简单，只需要给每条SELECT语句之间放上关键词UNION</p>
<p>举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用WHERE子句来完成此工作，不过这次我们将使用UNION。</p>
<p>第一条语句：<code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5;</code></p>
<p>第二条语句：<code>SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002);</code></p>
<p>这两条语句中，第一句找出价格不高于5的所有物品。第二句找出供应商1001和1002生产的所有商品。</p>
<p>现在对这两条语句进行组合：</p>
<p>使用UNION：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_price &lt;= 5			-- 注意：此处没有 &#x27;;&#x27;</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE vend_id IN (1001, 1002);</span><br><span class="line">-- result</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure>

<p>可以看到进行了联合操作，将所有的结果取了并集。</p>
<blockquote>
<p>当然此处也可以使用<code>WHERE</code>进行查询，但是若使用WHERE查询，无法从多个表查到结果，例如，有两个不同用户的表，都要查询包含一条物品的购买的信息，使用WHERE就很难做到，但是使用<code>UNION</code>会特别简单。</p>
</blockquote>
<h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul>
<li><p>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</p>
</li>
<li><p>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</p>
</li>
</ul>
<h4 id="包含重复行"><a href="#包含重复行" class="headerlink" title="包含重复行"></a>包含重复行</h4><p>使用UNION会返回两个结果的并集，而其交集部分会被合并，若不想让其合并，可以使用<code>UNION ALL</code>返回所有的行。</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5			-- 注意：此处没有 &#x27;;&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE vend_id IN (1001, 1002);</span><br><span class="line">-- result</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |		-- *注意重复出现两次</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 |		-- *注意重复出现两次</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> WHERE子句实现不了这个功能，若要进行这样的操作，必须使用UNION ALL而不是WHERE；</p>
</blockquote>
<h4 id="对组合语句进行排序"><a href="#对组合语句进行排序" class="headerlink" title="对组合语句进行排序"></a>对组合语句进行排序</h4><p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5			-- 注意：此处没有 &#x27;;&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT vend_id, prod_id, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE vend_id IN (1001, 1002)</span><br><span class="line">ORDER BY prod_price DESC; </span><br><span class="line">-- result</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure>

<h3 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h3><blockquote>
<p><strong>并非所有引擎都支持全文本搜索</strong> MySQL支持几种基本的数据库引擎。但并非所有的引擎都支持全文本搜索。<code>两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</code>这就是为什么虽然模板样例创建的多数样例表使用InnoDB，但样例表（productnotes表）却使用MyISAM。如果应用中需要全文本搜索功能，应该记住这一点。</p>
</blockquote>
<h4 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h4><p>为了进行全文本搜索，必须索引被搜索的列，而且要在数据改变后能够重新进行索引，因此在对表列进行设计后，MySQL会自动进行所有的索引和重新索引。</p>
<p>在索引之后，SELECT可与Match()和Against()一起使用以执行搜索。</p>
<h5 id="启用文本搜索"><a href="#启用文本搜索" class="headerlink" title="启用文本搜索"></a>启用文本搜索</h5><p>一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。</p>
<p>本样例的productnotes表的CREATE TABLE语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `productnotes` (</span><br><span class="line">  `note_id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `prod_id` char(10) NOT NULL,</span><br><span class="line">  `note_date` datetime NOT NULL,</span><br><span class="line">  `note_text` text,</span><br><span class="line">  PRIMARY KEY (`note_id`),</span><br><span class="line">  FULLTEXT KEY `note_text` (`note_text`)</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=115 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure>

<p>此语句中，在定义<code>note_text</code>列时，为了进行全文本搜索，使用了FULLTEXT(`note_text`)引导MySQL对其进行索引。这里的FULLTEXT索引单个列，若需要也可以索引多个列。</p>
<p><strong>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</strong></p>
<p><strong>可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引）。</strong></p>
<blockquote>
<p><strong>不要在导入数据时使用FULLTEXT</strong> 更新索引要花时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表，定义FULLTEXT。这样有助于更快地导入数据（而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间）。</p>
<p><strong>即：为了更快地导入大量数据，先导入数据再定义列为FULLTEXT，避免每次导入一个数据后都更新了一遍索引，大量数据导入后，一次定义即可更新全部索引。</strong></p>
</blockquote>
<h5 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h5><p>在索引完成之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;rabbit&#x27;);</span><br><span class="line">-- result</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                            |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |</span><br><span class="line">| Quantity varies, sold by the sack load. All guaranteed to be bright and orange, and suitable for use as rabbit bait. |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用完整地Match()说明</strong>  传递给Match() 的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p>
</blockquote>
<blockquote>
<p><strong>搜索不区分大小写</strong> 除非使用BINARY方式，否则全文本搜索不区分大小写。</p>
</blockquote>
<p>刚才地搜索也可以用LIKE子句完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE note_text LIKE &#x27;%rabbit%&#x27;;</span><br><span class="line">-- 也能查询到同样的结果</span><br></pre></td></tr></table></figure>

<p>但是使用全文本搜索和LIKE的最主要的区别是，前者（使用全文本搜索）返回以文本匹配<br>的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为第3个词的行的等级比作为第20个词的行高。这很重要。全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回（因为这些行很可能是你真正想要的行）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text, </span><br><span class="line">	   Match(note_text) Against(&#x27;rabbit&#x27;) AS ranklevel </span><br><span class="line">	   FROM productnotes;</span><br><span class="line">-- result</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span><br><span class="line">| note_text                                                                                                                                                 | ranklevel          |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span><br><span class="line">| Customer complaint:</span><br><span class="line">Sticks not individually wrapped, too easy to mistakenly detonate all at once.</span><br><span class="line">Recommend individual wrapping.                          |                  0 |</span><br><span class="line">| Can shipped full, refills not available.</span><br><span class="line">Need to order new can if refill needed.                                                                          |                  0 |</span><br><span class="line">| Safe is combination locked, combination not provided with safe.</span><br><span class="line">This is rarely a problem as safes are typically blown up or dropped by customers.         |                  0 |</span><br><span class="line">| Quantity varies, sold by the sack load.</span><br><span class="line">All guaranteed to be bright and orange, and suitable for use as rabbit bait.                                      | 1.5905543565750122 |</span><br><span class="line">| Included fuses are short and have been known to detonate too quickly for some customers.</span><br><span class="line">Longer fuses are available (item FU1) and should be recommended. |                  0 |</span><br><span class="line">| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                            |                  0 |</span><br><span class="line">| Please note that no returns will be accepted if safe opened using explosives.                                                                             |                  0 |</span><br><span class="line">| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.  |                  0 |</span><br><span class="line">| Item is extremely heavy. Designed for dropping, not recommended for use with slings, ropes, pulleys, or tightropes.                                       |                  0 |</span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                              | 1.6408053636550903 |</span><br><span class="line">| Shipped unassembled, requires common tools (including oversized hammer).                                                                                  |                  0 |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Circular hole in safe floor can apparently be easily cut with handsaw.                                                                |                  0 |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.   |                  0 |</span><br><span class="line">| Call from individual trapped in safe plummeting to the ground, suggests an escape hatch be added.</span><br><span class="line">Comment forwarded to vendor.                            |                  0 |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------+</span><br></pre></td></tr></table></figure>

<p>此语句中：等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。正如所见，不包含词rabbit的行等级为0（因此不被前一例子中的WHERE子句选择）。确实包含词rabbit的两个行每行都有一个等级值，文本中词靠前的行的等级值比词靠后的行的等级值高。这个例子有助于说明全文本搜索如何排除行（排除那些等级为0的行），如何排序结果（按等级以降序排序）。</p>
<p><strong>正如所见，全文本搜索提供了简单LIKE搜索不能提供的功能。而且，由于数据是索引的，全文本搜索还相当快。</strong></p>
<h4 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h4><p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。</p>
<p>但考虑下面的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。</p>
<p>在使用查询扩展时，MySQL对数据和索引检索两遍来完成扫描：</p>
<ul>
<li><p>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；</p>
</li>
<li><p>其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用）。</p>
</li>
<li><p>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</p>
</li>
</ul>
<p>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。</p>
<blockquote>
<p><strong>只用于MySQL版本4.1.1或更高级的版本</strong> 查询扩展功能是在MySQL 4.1.1中引入的，因此不能用于之前的版本。</p>
</blockquote>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text </span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br><span class="line">-- result</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                                                                |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils. |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Sticks not individually wrapped, too easy to mistakenly detonate all at once.</span><br><span class="line">Recommend individual wrapping.                         |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.  |</span><br><span class="line">| Please note that no returns will be accepted if safe opened using explosives.                                                                            |</span><br><span class="line">| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                             |</span><br><span class="line">| Customer complaint:</span><br><span class="line">Circular hole in safe floor can apparently be easily cut with handsaw.                                                               |</span><br><span class="line">| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                           |</span><br><span class="line">+----------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此语句中：返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。</p>
<blockquote>
<p>使用查询扩展当表中的行越多，返回的结果也就越好。</p>
</blockquote>
<h4 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h4><p>以布尔方式，可以提供关于如下内容的细节：</p>
<ul>
<li>要匹配的词；</li>
<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li>
<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）；</li>
<li>表达式分组；</li>
<li>另外一些内容。</li>
</ul>
<blockquote>
<p><strong>即使没有FULLTEXT索引也可以使用</strong> 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于， 即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。</p>
</blockquote>
<p>使用<code>IN BOOLEAN MODE</code>可以进行布尔文本搜索：</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE);</span><br><span class="line">-- result</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| note_text                                                                                                                                               |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Customer complaint:</span><br><span class="line">Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |</span><br><span class="line">+---------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>此语句匹配包含词heavy，但是-rope*表示排除<code>rope*</code>，即以rope开头的词语(包括ropes等)</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>包含，词必须存在</td>
</tr>
<tr>
<td>-</td>
<td>排除，词必须不出现</td>
</tr>
<tr>
<td>&gt;</td>
<td>包含，而且增加等级值</td>
</tr>
<tr>
<td>&lt;</td>
<td>包含，且减少等级值</td>
</tr>
<tr>
<td>()</td>
<td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td>~</td>
<td>取消一个词的排序值</td>
</tr>
<tr>
<td>*</td>
<td>词尾的通配符</td>
</tr>
<tr>
<td>“”</td>
<td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td>
</tr>
</tbody></table>
<p>举例说明：</p>
<ul>
<li><p><code>Match(note_text) Against(&#39;+rabbit + bait&#39; IN BOOLEAN MODE);</code></p>
<p>这个用来搜索匹配包含词rabbit和bait的行；</p>
</li>
<li><p><code>Match(note_text) Against(&#39;rabbit bait&#39; IN BOOLEAN MODE);</code></p>
<p>这个用来匹配rabbit和bait包含两者中至少一个的行；</p>
</li>
<li><p><code>Match(note_text) Against(&#39;&quot;rabbit bait&quot;&#39; IN BOOLEAN MODE);</code></p>
<p>这个用来匹配短语rabbit bait而不是匹配两个词rabbit和bait；</p>
</li>
<li><p><code>Match(note_text) Against(&#39;&gt;rabbit &lt;bait&#39; IN BOOLEAN MODE);</code></p>
<p>匹配rabbit和carrot，增加前者的等级，降低后者的等级；</p>
</li>
<li><p><code>Match(note_text) Against(&#39;+safe +(&lt;combination)&#39; IN BOOLEAN MODE);</code></p>
<p>这个搜索匹配词safe和combination，降低后者的等级；</p>
</li>
</ul>
<blockquote>
<p>在布尔方式中，不按照等级值降序排序返回的行。</p>
</blockquote>
<h4 id="全文本搜索的使用说明"><a href="#全文本搜索的使用说明" class="headerlink" title="全文本搜索的使用说明"></a>全文本搜索的使用说明</h4><ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。</li>
<li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don’t索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li>
<li>仅在MyISAM数据库引擎中支持全文本搜索。</li>
</ul>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>使用``INSERT`可以执行数据的插入，可以有以下的几种使用方式：</p>
<ul>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入多行；</li>
<li>插入某些查询的结果。</li>
</ul>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><p>基本语法实例如下：<br>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers</span><br><span class="line">VALUES(NULL,</span><br><span class="line">      &#x27;HeavyTiger&#x27;,</span><br><span class="line">      &#x27;WHUT&#x27;,</span><br><span class="line">      &#x27;Wu Han&#x27;,</span><br><span class="line">      &#x27;WH&#x27;,</span><br><span class="line">      &#x27;430000&#x27;,</span><br><span class="line">      &#x27;CHN&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      NULL);</span><br><span class="line">-- result</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">-- query2</span><br><span class="line">select * from customers;</span><br><span class="line">+---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+</span><br><span class="line">| cust_id | cust_name      | cust_address        | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email          |</span><br><span class="line">+---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+</span><br><span class="line">|   10001 | Coyote Inc.    | 200 Maple Lane      | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com     |</span><br><span class="line">|   10002 | Mouse House    | 333 Fromage Lane    | Columbus  | OH         | 43333    | USA          | Jerry Mouse  | NULL                |</span><br><span class="line">|   10003 | Wascals        | 1 Sunny Place       | Muncie    | IN         | 42222    | USA          | Jim Jones    | rabbit@wascally.com |</span><br><span class="line">|   10004 | Yosemite Place | 829 Riverside Drive | Phoenix   | AZ         | 88888    | USA          | Y Sam        | sam@yosemite.com    |</span><br><span class="line">|   10005 | E Fudd         | 4545 53rd Street    | Chicago   | IL         | 54545    | USA          | E Fudd       | NULL                |</span><br><span class="line">|   10006 | HeavyTiger     | WHUT                | Wu Han    | WH         | 430000   | CHN          | NULL         | NULL                |</span><br><span class="line">+---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>INSERT语句一般不会产生输出</p>
</blockquote>
<p>虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。因此，编写依赖于特定列次序的SQL语句是很不安全的。如果这样做，有时难免会出问题。</p>
<p>更好的方法是指定插入的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_email</span><br><span class="line">                  	 )</span><br><span class="line">               VALUES(&#x27;dcm&#x27;,</span><br><span class="line">      				&#x27;WHUT&#x27;,</span><br><span class="line">      				&#x27;Wu Han&#x27;,</span><br><span class="line">      				&#x27;WH&#x27;,</span><br><span class="line">      				&#x27;430000&#x27;,</span><br><span class="line">      				&#x27;CHN&#x27;,</span><br><span class="line">      				NULL,</span><br><span class="line">      				NULL</span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>

<p>因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。<strong>其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。</strong>你会发现cust_id的NULL值是不必要的，cust_id列并没有出现在列表中，所以不需要任何值。</p>
<blockquote>
<p><strong>总是使用列的列表</strong> 一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p>
</blockquote>
<blockquote>
<p><strong>省略列</strong> 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。</p>
<ul>
<li><p>该列定义为允许NULL值（无值或空值）。</p>
</li>
<li><p>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</p>
<p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>提高整体性能</strong> 数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。</p>
<p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，如下所示：</p>
<p><code>INSERT LOW_PRIORITY INTO</code></p>
<p>顺便说一下，这也适用于UPDATE和DELETE语句。</p>
</blockquote>
<h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><p>可以以分号结尾，直接输入多个插入行语句，也可以在VALUES中设置多组值；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country</span><br><span class="line">                  	 )</span><br><span class="line">               VALUES(&#x27;test1&#x27;,</span><br><span class="line">      				&#x27;WHUT&#x27;,</span><br><span class="line">      				&#x27;Wu Han&#x27;,</span><br><span class="line">      				&#x27;WH&#x27;,</span><br><span class="line">      				&#x27;430000&#x27;,</span><br><span class="line">      				&#x27;CHN&#x27;</span><br><span class="line">                    ),</span><br><span class="line">                    (&#x27;test2&#x27;,</span><br><span class="line">      				&#x27;WHUT&#x27;,</span><br><span class="line">      				&#x27;Wu Han&#x27;,</span><br><span class="line">      				&#x27;WH&#x27;,</span><br><span class="line">      				&#x27;430000&#x27;,</span><br><span class="line">      				&#x27;CHN&#x27;</span><br><span class="line">                    );</span><br><span class="line">                    </span><br><span class="line">-- result</span><br><span class="line">|   10008 | test1          | WHUT                | Wu Han    | WH         | 430000   | CHN          | NULL         | NULL                |</span><br><span class="line">|   10009 | test2          | WHUT                | Wu Han    | WH         | 430000   | CHN          | NULL         | NULL                |</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>可以提高INSERT的性能</strong> 此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入，比使用多条INSERT语句更快。</p>
</blockquote>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>若想把检索筛选出的客户数据（例如消费金额大于1w的VIP客户），插入到另一张表中，一条一条插入太浪费时间，因此可以使用<code>INSERT SELECT</code>语句执行该操作。</p>
<p>假设存在一张叫做custnew的表存储客户的数据，欲将该表导入到customers表中：</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO customers(cust_id,</span><br><span class="line">                     cust_email,</span><br><span class="line">                     cust_contact,</span><br><span class="line">    				 cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country</span><br><span class="line">                  	 )</span><br><span class="line">              SELECT cust_id,</span><br><span class="line">                     cust_email,</span><br><span class="line">                     cust_contact,</span><br><span class="line">    				 cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country</span><br><span class="line">                FROM custnew;</span><br></pre></td></tr></table></figure>

<p>此语句中：</p>
<p>使用INSERT SELECT从custnew中将所有数据导入customers。SELECT语句从custnew检索出要插入的值，而不是列出它们。SELECT中列出的每个列对应于customers表名后所跟的列表中的每个列。这条语句将插入多少行有赖于custnew表中有多少行。如果这个表为空，则没有行被插入（也不产生错误，因为操作仍然是合法的）。如果这个表确实含有数据，则所有数据将被插入到customers。</p>
<p>这个例子导入了cust_id（假设能够确保cust_id的值不重复）。也可以简单地省略这列（从INSERT和SELECT中），这样MySQL就会生成新值。</p>
<p><strong>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。</strong></p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>使用UPDATE语句，可以达到更新表中数据的目的，有以下两种方式使用UPDATE：</p>
<ul>
<li>更新表中的特定列；</li>
<li>更新表中的所有行。</li>
</ul>
<blockquote>
<p><strong>不要省略WHERE子句</strong> 在使用UPDATE时一定要注意细心。因为稍不注意，就会更新表中所有行。</p>
</blockquote>
<p>UPDATE语句非常容易使用，甚至可以说是太容易使用了。基本的UPDATE语句由3部分组成，分别是：</p>
<ul>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新行的过滤条件。</li>
</ul>
<p>假设需要更新客户10005的电子邮件地址，因此他的记录需要更新，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br><span class="line">-- result</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">-- query2</span><br><span class="line">SELECT cust_id, cust_email FROM customers WHERE cust_id = 10005;</span><br><span class="line">-- result</span><br><span class="line">+---------+----------------+</span><br><span class="line">| cust_id | cust_email     |</span><br><span class="line">+---------+----------------+</span><br><span class="line">|   10005 | elmer@fudd.com |</span><br><span class="line">+---------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若没有告诉更新哪里的数据，将会更新所有人的cust_email为<a href="mailto:&#101;&#x6c;&#109;&#x65;&#114;&#x40;&#x66;&#x75;&#100;&#100;&#x2e;&#x63;&#x6f;&#x6d;">&#101;&#x6c;&#109;&#x65;&#114;&#x40;&#x66;&#x75;&#100;&#100;&#x2e;&#x63;&#x6f;&#x6d;</a>;</p>
</blockquote>
<p><strong>更新多个列：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_name = &#x27;The Fudds&#x27;,</span><br><span class="line">	cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>

<p>在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。在此例子中，更新客户10005的cust_name和cust_email列。</p>
<blockquote>
<p><strong>在UPDATE语句中使用子查询</strong> UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</p>
</blockquote>
<blockquote>
<p><strong>IGNORE关键字</strong> 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：<br><code>UPDATE IGNORE customers…</code></p>
</blockquote>
<p>为了删除某个列，也可以设置其为NULL，将其中的值删除</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE：</p>
<ul>
<li>从表中删除特定的行；</li>
<li>从表中删除所有行。</li>
</ul>
<blockquote>
<p><strong>不要省略WHERE子句</strong> 在使用DELETE时一定要注意细心。因为稍不注意，就会错误地删除表中所有行。</p>
</blockquote>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers</span><br><span class="line">WHERE cust_id = 10006;</span><br></pre></td></tr></table></figure>

<p>为了删除指定的列，使用UPDATE语句，可以达到要求。</p>
<blockquote>
<p><strong>删除表的内容而不是表</strong> DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身。</p>
</blockquote>
<blockquote>
<p><strong>更快的删除</strong> 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p>
</blockquote>
<h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><p>下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</li>
</ul>
<blockquote>
<p><strong>小心使用</strong> MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</p>
</blockquote>
<h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>MySQL不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。</p>
<p>一般有两种创建表的方法：</p>
<ul>
<li>使用具有交互式创建和管理表的工具（如第2章讨论的工具）；</li>
<li>表也可以直接用MySQL语句操纵。</li>
</ul>
<h4 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h4><p>使用<code>CREATE TABLE</code>创建表，必须给出以下信息：</p>
<ul>
<li>新表的名字，在关键字CREATE TABLE之后给出；</li>
<li>表列的名字和定义，用逗号分隔。</li>
</ul>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">	cust_id 			int 		NOT NULL AUTO_INCREMENT,</span><br><span class="line">    cust_name  			char(50)	NOT NULL,</span><br><span class="line">    cust_address 		char(50)	NULL,</span><br><span class="line">    cust_city 			char(50)	NULL,</span><br><span class="line">    cust_state 			char(5)		NULL,</span><br><span class="line">    cust_zip 			char(10)	NULL,</span><br><span class="line">    cust_country 		char(50)	NULL,</span><br><span class="line">    cust_contact 		char(50)	NULL,</span><br><span class="line">    cust_email 			char(255)	NULL,</span><br><span class="line">    PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE = InnoDB</span><br></pre></td></tr></table></figure>

<p>此语句中：表名紧跟在CREATE TABLE关键字后面。实际的表定义（所有列）括在圆括号之中。各列之间用逗号分隔。这个表由9列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型。表的主键可以在创建表时用PRIMARY KEY关键字指定。这里，列cust_id指定作为主键列。整条语句由右圆括号后的分号结束。</p>
<blockquote>
<p><strong>处理现有的表</strong> 在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表，然后再重建它，而不是简单地用创建表语句覆盖它。</p>
<p>如果你仅想在一个表不存在时创建它，应该在表名后给出<code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。</p>
</blockquote>
<h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><p>允许NULL值即允许在插入行时不给出该列的值。不允许NULL值则表示不接受不提供该值的行。每一个表列都需要在创建时给出定义规定。</p>
<p>如6.1.1中的例子，NOT NULL表示不允许插入NULL，将会阻止插入没有值的列。如果试图插入没有值的列，将返回错误，且插入失败。NULL不是必须的，不指定NOT NULL则默认为NULL。</p>
<blockquote>
<p><strong>理解NULL</strong> 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。</p>
</blockquote>
<h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>正如所述，主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p>
<p>迄今为止我们看到的CREATE TABLE例子都是用单个列作为主键。其中主键用以下的类似的语句定义：</p>
<p><code>PRIMARY KEY (vend_id)</code></p>
<p>若创建由多个列组成的主键，则应该以逗号分隔的列表给出各个列名，例如：</p>
<p><code>PRIMARY KEY (order_num, order_item)</code></p>
<p>此时二者共同表示主键，每个订单号（order_num）和订单物品（order_item）列的组合是唯一的，因此可以被作为主键。</p>
<p>主键可以在创建表时定义，也可以在创建表后定义；</p>
<blockquote>
<p><strong>主键和NULL值</strong> 主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。</p>
</blockquote>
<h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><p><code>AUTO_INCREMENT</code>告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的key_id，从而可以用作主键值。</p>
<blockquote>
<p><strong>覆盖AUTO_INCREMENT</strong> 如果一个列被指定为AUTO_INCREMENT，则它需要使用特殊的值吗？你可以简单地在INSERT语句<br>中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值。</p>
</blockquote>
<blockquote>
<p><strong>确定AUTO_INCREMENT值</strong> 让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。</p>
<p>考虑这个场景：你正在增加一个新订单。这要求在orders表中创建一行，然后在orderitms表中对订购的每项物品创建一行。主键order_num（自动生成）在orderitems表中与订单细节一起存储。这就是为什么orders表和orderitems表为相互关联的表的原因。这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num。</p>
<p>那么，如何在使用AUTO_INCREMENT列时获得这个值呢？可使用last_insert_id()函数获得这个值，如下所示：<br><code>SELECT last_insert_id()</code><br>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句。</p>
</blockquote>
<h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><p>若在插入行时没有给出具体的值，MySQL允许指定此时使用的默认值。默认值使用<code>CREATE TABLE</code>中的<code>DEFAULT</code>关键词指定。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE orderitems(</span><br><span class="line">	order_num 		int 		NOT NULL,</span><br><span class="line">    order_item		int			NOT NULL,</span><br><span class="line">    quantity		int 		NOT NULL DEFAULT 1;</span><br><span class="line">    PRIMARY KEY(order_num, order_item)</span><br><span class="line">) ENGINE = InnoDB</span><br></pre></td></tr></table></figure>

<p>此语句中：设定了quantity的默认值为1，在未给出数量的情况下，将直接使用数量1。</p>
<blockquote>
<p><strong>不允许函数</strong> 与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p>
</blockquote>
<blockquote>
<p><strong>使用默认值而不是NULL值</strong> 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。</p>
</blockquote>
<h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><p>MySQL有一个具体管理和处理数据的内部引擎。在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候，此引擎都隐藏在DBMS内，不需要过多关注它。</p>
<p>但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。</p>
<p>为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p>
<p>当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因。</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</li>
<li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li>
</ul>
<p>引擎类型可以混用。参考书籍中提供的数据库样例，除productnotes表使用MyISAM外，其他样例表都使用InnoDB。原因是作者希望支持事务处理（因此，使用InnoDB），但也需要在productnotes中支持全文本搜索（因此，使用MyISAM）。</p>
<blockquote>
<p><strong>外键不能跨引擎</strong> 混用引擎类型有一个大缺陷。外键不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p>
</blockquote>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，当表中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。</p>
<p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p>
<ul>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>所做更改的列表。</li>
</ul>
<p>使用语句给表添加一个列：</p>
<p><code>ALTER TABLE vendors ADD vend_phone CHAR(20);</code></p>
<p>删除刚刚添加的列：</p>
<p><code>ALTER TABLE vendors DROP COLUMN vend_phone;</code></p>
<p>可以用该语句定义外键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- first</span><br><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREIGN KEY (order_num) </span><br><span class="line">REFERENCES orders (order_num);</span><br><span class="line">-- second</span><br><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_products</span><br><span class="line">FOREIGN KEY (prod_id) </span><br><span class="line">REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure>

<p>复杂的表结构的更改一般需要手动删除的过程，一般涉及到如下步骤：</p>
<ul>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ul>
<blockquote>
<p><strong>小心使用ALTER TABLE</strong> 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
</blockquote>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>使用<code>DORP TABLE</code>语句可以很容易实现此功能：</p>
<p><code>DROP TABLE customers2;</code></p>
<p>这条语句删除customers2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。</p>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><p>使用<code>RENAME TABLE</code>语句对表进行重命名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">			 backup_vendors TO vendors,</span><br><span class="line">			 backup_products TO products;</span><br></pre></td></tr></table></figure>

<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><blockquote>
<p><strong>需要MySQL 5</strong> MySQL 5添加了对视图的支持。因此，本内容适用于MySQL 5及以后的版本。</p>
</blockquote>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>例如之前使用的查询三个表中的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">  AND orderitems.order_num = orders.order_num</span><br><span class="line">  AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>此查询用来检索订购了某个特定产品的客户。任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。</p>
<p><strong>假设有办法将整个查询包装成一个名为productcustomers的虚拟表，则可以很容易地使用以下语句达成目的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>作为视图，他不应该包含表中的任何列或者数据，它包含的是一个SQL查询。</p>
<h4 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h4><p>我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。</p>
<ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。</p>
<p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<blockquote>
<p><strong>性能问题</strong> 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
</blockquote>
<h4 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h4><p>下面是关于视图创建和使用的一些最常见的规则和限制。</p>
<ul>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li>
<li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</li>
</ul>
<h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><ul>
<li>视图用CREATE VIEW语句来创建。</li>
<li>使用SHOW CREATE VIEW viewname；来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为DROP VIEW viewname;。</li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE ORREPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li>
</ul>
<h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。</p>
<p>使用语句创建视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS</span><br><span class="line">	SELECT cust_name, cust_contact, prod_id</span><br><span class="line">	FROM customers, orders, orderitems</span><br><span class="line">	WHERE customers.cust_id = orders.cust_id</span><br><span class="line">  	  AND orderitems.order_num = orders.order_num;</span><br><span class="line">  	  </span><br><span class="line">  	  </span><br><span class="line">-- use</span><br><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;;</span><br><span class="line">-- result</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br></pre></td></tr></table></figure>

<h4 id="使用视图重新格式化检索出的数据"><a href="#使用视图重新格式化检索出的数据" class="headerlink" title="使用视图重新格式化检索出的数据"></a>使用视图重新格式化检索出的数据</h4><p>假设经常进行某项数据的拼接格式化工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country), &#x27;)&#x27;)</span><br><span class="line">	AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br><span class="line">-- 可以对此创建一个视图，在每次使用时直接索引视图</span><br><span class="line">CREATE VIEW vend_locations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country), &#x27;)&#x27;)</span><br><span class="line">	AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br><span class="line">-- test</span><br><span class="line">SELECT * FROM vend_locations;</span><br><span class="line">-- result</span><br><span class="line">+------------------------+</span><br><span class="line">| vend_title             |</span><br><span class="line">+------------------------+</span><br><span class="line">| ACME(USA)              |</span><br><span class="line">| Anvils R Us(USA)       |</span><br><span class="line">| Furball Inc.(USA)      |</span><br><span class="line">| Jet Set(England)       |</span><br><span class="line">| Jouets Et Ours(France) |</span><br><span class="line">| LT Supplies(USA)       |</span><br><span class="line">+------------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="使用视图过滤掉不想要的数据"><a href="#使用视图过滤掉不想要的数据" class="headerlink" title="使用视图过滤掉不想要的数据"></a>使用视图过滤掉不想要的数据</h4><p>使用视图过滤掉没有电子邮件地址的客户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br><span class="line">-- create view</span><br><span class="line">CREATE VIEW customeremaillist AS </span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br><span class="line">-- test</span><br><span class="line">SELECT * FROM customeremaillist;</span><br><span class="line">-- result</span><br><span class="line">+---------+----------------+---------------------+</span><br><span class="line">| cust_id | cust_name      | cust_email          |</span><br><span class="line">+---------+----------------+---------------------+</span><br><span class="line">|   10001 | Coyote Inc.    | ylee@coyote.com     |</span><br><span class="line">|   10003 | Wascals        | rabbit@wascally.com |</span><br><span class="line">|   10004 | Yosemite Place | sam@yosemite.com    |</span><br><span class="line">|   10005 | E Fudd         | elmer@fudd.com      |</span><br><span class="line">+---------+----------------+---------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="使用视图和计算字段"><a href="#使用视图和计算字段" class="headerlink" title="使用视图和计算字段"></a>使用视图和计算字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW orderitemsexpanded AS</span><br><span class="line">SELECT prod_id, quantity, item_price,</span><br><span class="line">	   quantity * item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br><span class="line">-- test</span><br><span class="line">SELECT * FROM orderitemsexpanded ORDER BY expanded_price DESC;</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| prod_id | quantity | item_price | expanded_price |</span><br><span class="line">+---------+----------+------------+----------------+</span><br><span class="line">| TNT2    |      100 |      10.00 |        1000.00 |</span><br><span class="line">| FC      |       50 |       2.50 |         125.00 |</span><br><span class="line">| ANV01   |       10 |       5.99 |          59.90 |</span><br><span class="line">| JP2000  |        1 |      55.00 |          55.00 |</span><br><span class="line">| TNT2    |        5 |      10.00 |          50.00 |</span><br><span class="line">| ANV02   |        3 |       9.99 |          29.97 |</span><br><span class="line">| ANV03   |        1 |      14.99 |          14.99 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">| FB      |        1 |      10.00 |          10.00 |</span><br><span class="line">| OL1     |        1 |       8.99 |           8.99 |</span><br><span class="line">| SLING   |        1 |       4.49 |           4.49 |</span><br><span class="line">+---------+----------+------------+----------------+</span><br></pre></td></tr></table></figure>

<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>迄今为止的所有视图都是和SELECT语句使用的。然而，视图的数据能否更新？答案视情况而定。</p>
<p>通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ul>
<li><p>分组（使用GROUP BY和HAVING）；</p>
</li>
<li><p>联结；</p>
</li>
<li><p>子查询；</p>
</li>
<li><p>并；</p>
</li>
<li><p>聚集函数（Min()、Count()、Sum()等）；</p>
</li>
<li><p>DISTINCT；</p>
</li>
<li><p>导出（计算）列。</p>
</li>
</ul>
<p>换句话说，本章许多例子中的视图都是不可更新的。这听上去好像是一个严重的限制，但实际上不是，因为视图主要用于数据检索。</p>
<blockquote>
<p><strong>将视图用于检索</strong> 一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p>
</blockquote>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><blockquote>
<p><strong>需要MySQL 5</strong> MySQL 5添加了对存储过程的支持，因此，适用于MySQL 5及以后的版本。</p>
</blockquote>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。例如，考虑以下的情形。</p>
<ul>
<li>为了处理订单，需要核对以保证库存中有相应的物品。</li>
<li>如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量。</li>
<li>库存中没有的物品需要订购，这需要与供应商进行某种交互。</li>
<li>关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户。</li>
</ul>
<p>这显然不是一个完整的例子，它甚至超出了本书中所用样例表的范围，但足以帮助表达我们的意思了。执行这个处理需要针对许多表的多条MySQL语句。此外，需要执行的具体语句及其次序也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。</p>
<p>那么，怎样编写此代码？可以单独编写每条语句，并根据结果有条件地执行另外的语句。在每次需要这个处理时（以及每个需要它的应用中）都必须做这些工作。</p>
<p>可以创建存储过程。存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><p><strong>优点：</strong></p>
<ul>
<li><p>通过把处理封装在容易使用的单元中，简化复杂的操作</p>
</li>
<li><p>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</p>
</li>
<li><p>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</p>
</li>
<li><p>这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</p>
</li>
<li><p>提高性能。因为使用存储过程比使用单独的SQL语句要快。</p>
</li>
<li><p>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。</p>
</li>
<li><p>可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。</p>
</li>
</ul>
<p>尽管有这些缺陷，存储过程还是非常有用的，并且应该尽可能地使用。</p>
<h3 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。</p>
<p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow</span><br><span class="line">                    @pricehigh</span><br><span class="line">                    @priceaverage</span><br><span class="line">                   );</span><br></pre></td></tr></table></figure>

<p>此语句中：将执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。</p>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><h5 id="无参存储过程"><a href="#无参存储过程" class="headerlink" title="无参存储过程"></a>无参存储过程</h5><p>使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>此语句中：存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟()仍然需要。BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句。</p>
<p>在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。</p>
<blockquote>
<p><strong>mysql命令行客户机的分隔符</strong> 如果使用的是mysql命令行，应该仔细阅读此说明。</p>
<p>默认的MySQL语句分隔符为<code>;</code>。mysql命令行实用程序也使用<code>;</code>作为语句分隔符。如果命令行要解释存储过程自身内的<code>;</code>字符，则它们最终不会成为存储过程的内容，这会使存储过程中的SQL出现句法错误。</p>
<p>解决办法是临时更改命令行实用程序的语句分隔符，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;DELIMITER //</span><br><span class="line"></span><br><span class="line">&gt;CREATE PROCEDURE productpricing()</span><br><span class="line">&gt;BEGIN</span><br><span class="line">SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">FROM products;</span><br><span class="line">&gt;END //</span><br><span class="line"></span><br><span class="line">&gt;DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>其中，<code>DELIMITER //</code>告诉命令行实用程序使用<code>//</code>作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为<code>END//</code>而不是<code>END;</code>。这样，存储过程体内的<code>;</code>仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符，可使用<code>DELIMITER ;</code>。除<code>\</code>符号外，任何字符都可以用作语句分隔符。</p>
</blockquote>
<p>使用<code>CALL productpricing();</code>可以调用这个存储过程；</p>
<h5 id="含参存储过程"><a href="#含参存储过程" class="headerlink" title="含参存储过程"></a>含参存储过程</h5><p>productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</p>
<blockquote>
<p><strong>变量（variable）</strong>内存中一个特定的位置，用来临时存储数据。</p>
</blockquote>
<p>使用有参存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">	OUT pl DECIMAL(8, 2),</span><br><span class="line">    OUT ph DECIMAL(8, 2),</span><br><span class="line">    OUT pa DECIMAL(8, 2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Min(prod_price)</span><br><span class="line">	INTO pl</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Max(prod_price)</span><br><span class="line">	INTO ph</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Avg(prod_price)</span><br><span class="line">	INTO pa</span><br><span class="line">	FROM products;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。</p>
<blockquote>
<p><strong>参数的数据类型</strong></p>
<p>切记不能使用一个参数返回多个行和列，记录集是不被允许的。</p>
</blockquote>
<p>调用含参存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @pricecaverage);</span><br></pre></td></tr></table></figure>

<p>它们是存储过程将保存结果的3个变量的名字。所有MySQL变量都必须以<code>@</code>开始。</p>
<p>为了检索变量，可以使用如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT @pricelow;</span><br><span class="line">+-----------+</span><br><span class="line">| @pricelow |</span><br><span class="line">+-----------+</span><br><span class="line">|      2.50 |</span><br><span class="line">+-----------+</span><br><span class="line">SELECT @pricelow, @pricehigh, @pricecaverage;</span><br><span class="line">+-----------+------------+----------------+</span><br><span class="line">| @pricelow | @pricehigh | @pricecaverage |</span><br><span class="line">+-----------+------------+----------------+</span><br><span class="line">|      2.50 |      55.00 |          16.13 |</span><br><span class="line">+-----------+------------+----------------+</span><br></pre></td></tr></table></figure>

<p>使用含入参的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE ordercount(</span><br><span class="line">	IN onum INT,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN </span><br><span class="line">	SELECT Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onum</span><br><span class="line">	INTO ototal;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- test</span><br><span class="line"></span><br><span class="line">CALL ordercount(20005, @total);</span><br><span class="line">SELECT @total;</span><br><span class="line">-- result</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">| 149.87 |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">-- test2</span><br><span class="line">CALL ordercount(20009, @total);</span><br><span class="line">SELECT @total;</span><br><span class="line">-- result</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">|  38.47 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>

<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>使用语句:</p>
<p><code>DROP PROCEDURE productpricing;</code></p>
<p>若需要更安全，可以使用仅当存在时删除：</p>
<p><code>DROP PROCEDURE productpricing IF EXISTS;</code></p>
<h4 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h4><p>使用智能存储过程可以处理更加复杂的规则和业务。</p>
<p>假如，需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客。那么，需要做下面几件事情：</p>
<ul>
<li>获得合计（与以前一样）；</li>
<li>把营业税有条件地添加到合计；</li>
<li>返回合计（带或不带税）。</li>
</ul>
<p>建立存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertotal</span><br><span class="line">-- Praameters: onumber = order number</span><br><span class="line">-- 			   tax = order number</span><br><span class="line">-- 			   ototal = order total variable</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">    IN taxable BOOLEAN,</span><br><span class="line">    OUT ototal DECIMAL(8, 2)</span><br><span class="line">) COMMENT &#x27;Obtain order total, optionally adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">	-- Declare variable for total</span><br><span class="line">	DECLARE total DECIMAL(8, 2);</span><br><span class="line">	-- Declare tax perceentage</span><br><span class="line">	DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">	</span><br><span class="line">	-- Get the order total</span><br><span class="line">	SELECT Sum(item_price * quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO total;</span><br><span class="line">	</span><br><span class="line">	-- Is this taxable?</span><br><span class="line">	IF taxable THEN</span><br><span class="line">		SELECT total + (total * taxrate / 100) INTO total;</span><br><span class="line">	END IF;</span><br><span class="line">	SELECT total INTO ototal;</span><br><span class="line">	END//</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>COMMENT关键字</strong> 本例子中的存储过程在CREATE PROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。</p>
</blockquote>
<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CALL ordertotal(20005, 0 , @total);</span><br><span class="line">SELECT @total;</span><br><span class="line">-- result</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">| 149.87 |</span><br><span class="line">+--------+</span><br><span class="line">-- test</span><br><span class="line">CALL ordertotal(20005, 1 , @total);</span><br><span class="line">SELECT @total;</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">| 158.86 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BOOLEAN值指定为1表示真，指定为0表示假（实际上，非零值都考虑为真，只有0被视为假）。通过给中间的参数指定0或1，可以有条件地将营业税加到订单合计上。</p>
</blockquote>
<blockquote>
<p><strong>IF语句</strong> 这个例子给出了MySQL的IF语句的基本用法。IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）。</p>
</blockquote>
<h4 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h4><p>使用语句：<code>SHOW CREATE PROCEDURE ordertotal;</code></p>
<p>可以显示创建存储过程的CREATE语句；</p>
<p>使用<code>SHOW PROCEDURE STATUS;</code></p>
<p>可以显示列出<strong>所有</strong>的存储过程，包括创建时间，由谁创建等信息；</p>
<p>为了显示相关数据，可以使用通配符匹配：<br><code>SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------+------------+-----------+----------------+---------------------+---------------------+---------------+-------------------------------------------+----------------------+----------------------+--------------------+</span><br><span class="line">| Db          | Name       | Type      | Definer        | Modified            | Created             | Security_type | Comment                                   | character_set_client | collation_connection | Database Collation |</span><br><span class="line">+-------------+------------+-----------+----------------+---------------------+---------------------+---------------+-------------------------------------------+----------------------+----------------------+--------------------+</span><br><span class="line">| crashcourse | ordertotal | PROCEDURE | root@localhost | 2021-09-29 09:10:20 | 2021-09-29 09:10:20 | DEFINER       | Obtain order total, optionally adding tax | utf8mb4              | utf8mb4_0900_ai_ci   | utf8mb4_0900_ai_ci |</span><br><span class="line">+-------------+------------+-----------+----------------+---------------------+---------------------+---------------+-------------------------------------------+----------------------+----------------------+--------------------+</span><br></pre></td></tr></table></figure>

<h2 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>MySQL检索操作返回一组称为结果集的行。这组返回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。</p>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<blockquote>
<p><strong>只能用于存储过程</strong> 不像多数DBMS，MySQL游标只能用于存储过程（和函数）。</p>
</blockquote>
<h3 id="使用游标-1"><a href="#使用游标-1" class="headerlink" title="使用游标"></a>使用游标</h3><p>使用游标需要以下几个步骤：</p>
<ul>
<li>在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。</li>
<li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在结束游标使用时，必须关闭游标。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>[1] 福塔(Forta, B.). MySQL必知必会[M]. 刘晓霞，钟鸣，译. —北京：人民邮电出版社，2009.1</p>
</blockquote>

    </div>

    
    
    

    <div>
    
        <div>
    
        <hr>
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文到此结束 <i class="fas fa-book-open"></i> 感谢您的阅读-------------</div>
    
</div>
    
    </div>
        <div class="reward-container">
  <div>谢谢你请我喝肥宅快乐水(๑＞ڡ＜) ☆☆☆</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatimg.jpg" alt="喵式重战 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipayimg.jpg" alt="喵式重战 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>喵式重战
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://heavytiger.github.io/articles/MySQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="MySQL基础学习">https://heavytiger.github.io/articles/MySQL基础学习/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/articles/TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/" rel="prev" title="TCP网络编程初探">
      <i class="fa fa-chevron-left"></i> TCP网络编程初探
    </a></div>
      <div class="post-nav-item">
    <a href="/articles/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E6%8E%A2/" rel="next" title="Tomcat服务器初探">
      Tomcat服务器初探 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E8%AF%86MySQL"><span class="nav-number">1.</span> <span class="nav-text">初识MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.</span> <span class="nav-text">MySQL的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BD%AF%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">SQL可视化软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%B0%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">测试基本的新建数据库操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.4.</span> <span class="nav-text">使用命令行界面连接数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">操作数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.</span> <span class="nav-text">SQL基本信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%EF%BC%88table%EF%BC%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">表（table）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%EF%BC%88schema%EF%BC%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">模式（schema）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%EF%BC%88column%EF%BC%89%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="nav-number">2.1.3.</span> <span class="nav-text">列（column）表中的一个字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%EF%BC%88row%EF%BC%89-%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">行（row） 表中的一个记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%EF%BC%88primary-key%EF%BC%89"><span class="nav-number">2.1.5.</span> <span class="nav-text">主键（primary key）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E6%A0%B7%E4%BE%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">导入样例的数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.2.1.</span> <span class="nav-text">创建数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.2.2.</span> <span class="nav-text">选取数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Ccreate-sql%E8%84%9A%E6%9C%AC"><span class="nav-number">2.2.3.</span> <span class="nav-text">执行create.sql脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cpopulate-sql%E8%84%9A%E6%9C%AC"><span class="nav-number">2.2.4.</span> <span class="nav-text">执行populate.sql脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%A1%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">查看表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%A1%A8%E5%88%97"><span class="nav-number">2.2.6.</span> <span class="nav-text">查看表列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.</span> <span class="nav-text">SELECT语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%88%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">检索单个列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%88%97"><span class="nav-number">3.1.2.</span> <span class="nav-text">检索多个列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%89%80%E6%9C%89%E5%88%97"><span class="nav-number">3.1.3.</span> <span class="nav-text">检索所有列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C"><span class="nav-number">3.1.4.</span> <span class="nav-text">检索不同的行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C"><span class="nav-number">3.1.5.</span> <span class="nav-text">限制结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E7%9A%84%E8%A1%A8%E5%90%8D"><span class="nav-number">3.1.6.</span> <span class="nav-text">使用完全限定的表名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text">排序数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E5%8D%95%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">按照单个列排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E5%A4%9A%E4%B8%AA%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">按照多个列进行排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91"><span class="nav-number">3.2.3.</span> <span class="nav-text">指定排序方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%80%BC"><span class="nav-number">3.2.4.</span> <span class="nav-text">查询最值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.</span> <span class="nav-text">过滤数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.3.1.</span> <span class="nav-text">WHERE子句操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%8D%95%E4%B8%AA%E5%80%BC"><span class="nav-number">3.3.2.</span> <span class="nav-text">检查单个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5"><span class="nav-number">3.3.3.</span> <span class="nav-text">不匹配检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-number">3.3.4.</span> <span class="nav-text">范围值检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-number">3.3.5.</span> <span class="nav-text">空值检查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">3.4.</span> <span class="nav-text">组合过滤数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AND%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.1.</span> <span class="nav-text">AND操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OR%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.2.</span> <span class="nav-text">OR操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AC%A1%E5%BA%8F"><span class="nav-number">3.4.3.</span> <span class="nav-text">计算次序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IN%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.4.</span> <span class="nav-text">IN操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NOT%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.5.</span> <span class="nav-text">NOT操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">3.5.</span> <span class="nav-text">通配符匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">3.5.1.</span> <span class="nav-text">百分号(%)通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">3.5.2.</span> <span class="nav-text">下划线(_)通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-number">3.5.3.</span> <span class="nav-text">使用通配符的技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">使用正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">3.6.1.</span> <span class="nav-text">基本字符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8COR%E5%8C%B9%E9%85%8D"><span class="nav-number">3.6.2.</span> <span class="nav-text">进行OR匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6"><span class="nav-number">3.6.3.</span> <span class="nav-text">匹配特定字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4"><span class="nav-number">3.6.4.</span> <span class="nav-text">匹配范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-number">3.6.5.</span> <span class="nav-text">匹配特殊字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">3.6.6.</span> <span class="nav-text">匹配字符类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.6.7.</span> <span class="nav-text">匹配多个实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="nav-number">3.6.8.</span> <span class="nav-text">定位符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">3.7.</span> <span class="nav-text">创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="nav-number">3.7.1.</span> <span class="nav-text">拼接字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Trim%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">Trim函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">使用别名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%AE%97%E6%9C%AF%E8%AE%A1%E7%AE%97"><span class="nav-number">3.7.2.</span> <span class="nav-text">执行算术计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.1.</span> <span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.2.</span> <span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.3.</span> <span class="nav-text">数值处理函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">3.9.</span> <span class="nav-text">汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.9.1.</span> <span class="nav-text">汇总函数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AVG"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">AVG()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#COUNT"><span class="nav-number">3.9.1.2.</span> <span class="nav-text">COUNT()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MAX-MIN"><span class="nav-number">3.9.1.3.</span> <span class="nav-text">MAX(), MIN()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SUM"><span class="nav-number">3.9.1.4.</span> <span class="nav-text">SUM()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="nav-number">3.9.2.</span> <span class="nav-text">聚集不同值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">3.9.3.</span> <span class="nav-text">组合聚集函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.10.</span> <span class="nav-text">分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84"><span class="nav-number">3.10.1.</span> <span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84"><span class="nav-number">3.10.2.</span> <span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84"><span class="nav-number">3.10.3.</span> <span class="nav-text">过滤分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">3.10.4.</span> <span class="nav-text">分组和排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT%E5%AD%90%E5%8F%A5%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.10.5.</span> <span class="nav-text">SELECT子句的顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.11.</span> <span class="nav-text">使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.11.1.</span> <span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">3.11.2.</span> <span class="nav-text">利用子查询进行过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.11.3.</span> <span class="nav-text">作为计算字段使用子查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="nav-number">3.12.</span> <span class="nav-text">联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E7%BB%93"><span class="nav-number">3.12.1.</span> <span class="nav-text">联结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="nav-number">3.12.1.1.</span> <span class="nav-text">关系表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93"><span class="nav-number">3.12.1.2.</span> <span class="nav-text">为什么要使用联结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%81%94%E7%BB%93"><span class="nav-number">3.12.2.</span> <span class="nav-text">创建联结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">3.12.2.1.</span> <span class="nav-text">WHERE子句的重要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-number">3.12.2.2.</span> <span class="nav-text">内部联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E5%A4%9A%E4%B8%AA%E8%A1%A8"><span class="nav-number">3.12.2.3.</span> <span class="nav-text">联结多个表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="nav-number">3.13.</span> <span class="nav-text">创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D"><span class="nav-number">3.13.1.</span> <span class="nav-text">使用表别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-number">3.13.2.</span> <span class="nav-text">使用不同类型的联结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E8%81%94%E7%BB%93"><span class="nav-number">3.13.2.1.</span> <span class="nav-text">自联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93"><span class="nav-number">3.13.2.2.</span> <span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-number">3.13.2.3.</span> <span class="nav-text">外部联结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A6%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-number">3.13.3.</span> <span class="nav-text">使用带聚集函数的联结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.14.</span> <span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.14.1.</span> <span class="nav-text">创建组合查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UNION"><span class="nav-number">3.14.2.</span> <span class="nav-text">使用UNION</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNION%E8%A7%84%E5%88%99"><span class="nav-number">3.14.3.</span> <span class="nav-text">UNION规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="nav-number">3.14.4.</span> <span class="nav-text">包含重复行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%BB%84%E5%90%88%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">3.14.5.</span> <span class="nav-text">对组合语句进行排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">3.15.</span> <span class="nav-text">全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">3.15.1.</span> <span class="nav-text">使用全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">3.15.1.1.</span> <span class="nav-text">启用文本搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">3.15.1.2.</span> <span class="nav-text">进行全文本搜索</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95"><span class="nav-number">3.15.2.</span> <span class="nav-text">使用查询扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">3.15.3.</span> <span class="nav-text">布尔文本搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">3.15.4.</span> <span class="nav-text">全文本搜索的使用说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5"><span class="nav-number">4.1.</span> <span class="nav-text">数据插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C"><span class="nav-number">4.2.</span> <span class="nav-text">插入完整的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E8%A1%8C"><span class="nav-number">4.3.</span> <span class="nav-text">插入多行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">4.4.</span> <span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">5.</span> <span class="nav-text">更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">更新数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.</span> <span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="nav-number">5.3.</span> <span class="nav-text">更新和删除的指导原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">6.1.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.1.</span> <span class="nav-text">表创建基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8NULL%E5%80%BC"><span class="nav-number">6.1.2.</span> <span class="nav-text">使用NULL值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE"><span class="nav-number">6.1.3.</span> <span class="nav-text">主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AUTO-INCREMENT"><span class="nav-number">6.1.4.</span> <span class="nav-text">使用AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">6.1.5.</span> <span class="nav-text">指定默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.6.</span> <span class="nav-text">引擎类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="nav-number">6.2.</span> <span class="nav-text">更新表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">6.3.</span> <span class="nav-text">删除表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="nav-number">6.4.</span> <span class="nav-text">重命名表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">7.1.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">7.1.1.</span> <span class="nav-text">为什么使用视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6"><span class="nav-number">7.1.2.</span> <span class="nav-text">视图的规则和限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE-1"><span class="nav-number">7.2.</span> <span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-number">7.2.1.</span> <span class="nav-text">利用视图简化复杂的联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.2.</span> <span class="nav-text">使用视图重新格式化检索出的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E6%8E%89%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.2.3.</span> <span class="nav-text">使用视图过滤掉不想要的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">7.2.4.</span> <span class="nav-text">使用视图和计算字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-number">7.2.5.</span> <span class="nav-text">更新视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.1.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.</span> <span class="nav-text">为什么要使用存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-1"><span class="nav-number">8.3.</span> <span class="nav-text">使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.1.</span> <span class="nav-text">执行存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.2.</span> <span class="nav-text">创建存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">无参存储过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AB%E5%8F%82%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">含参存储过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.3.</span> <span class="nav-text">删除存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.4.</span> <span class="nav-text">建立智能存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.3.5.</span> <span class="nav-text">检查存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="nav-number">9.</span> <span class="nav-text">使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-number">9.1.</span> <span class="nav-text">游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87-1"><span class="nav-number">9.2.</span> <span class="nav-text">使用游标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="喵式重战"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">喵式重战</p>
  <div class="site-description" itemprop="description">人的一切痛苦，本质上都是对自己无能的愤怒。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HeavyTiger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HeavyTiger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=o8fGzcTAy8bNxM7KwszjxczbzsLKz43AzM4" title="E-Mail → http:&#x2F;&#x2F;mail.qq.com&#x2F;cgi-bin&#x2F;qm_share?t&#x3D;qm_mailme&amp;email&#x3D;o8fGzcTAy8bNxM7KwszjxczbzsLKz43AzM4" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://tzhiy.github.io/" title="https:&#x2F;&#x2F;tzhiy.github.io&#x2F;" rel="noopener" target="_blank">tzhiy's Blog</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>
    

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fas fa-star fa-spin"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">喵式重战</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">151k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:17</span>
</div>

<!--
--><!--
<a href="https://icp.gov.moe/?keyword=20180708" rel="external nofollow noreferrer" target="_blank" data-pjax-state="" style="
    border-bottom-width: 0px;
">萌 ICP 备 20180708 号</a>
//-->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("6/8/2021 0:0:0");       //此处修改你的建站时间，注意格式
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "已经存活 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒了，地球太危险了，我好害怕，想回家呜呜呜( >﹏<。)";
    }
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"right","hOffset":0,"vOffset":-20,"width":200,"height":400},"mobile":{"show":true,"scale":0.7},"react":{"opacity":0.85},"log":false});</script></body>
</html>
