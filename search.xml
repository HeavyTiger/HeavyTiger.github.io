<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP网络编程初探</title>
      <link href="/articles/TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
      <url>/articles/TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<!--此处为希望博客在首页显示的内容--><p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p><span id="more"></span><!-- markdownlint-disable MD041 MD002--><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p><h2 id="JAVA网络编程——TCP协议"><a href="#JAVA网络编程——TCP协议" class="headerlink" title="JAVA网络编程——TCP协议"></a>JAVA网络编程——TCP协议</h2><h3 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h3><p>Socket 的原意是“插座”，在计算机通信领域，Socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p><p>当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。使用Socket套接字可以在IP地址的不同的端口下进行通信。</p><p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于特权端口，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p><p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><h2 id="C-S通信模式，TCP网络编程初探"><a href="#C-S通信模式，TCP网络编程初探" class="headerlink" title="C/S通信模式，TCP网络编程初探"></a>C/S通信模式，TCP网络编程初探</h2><h3 id="Server端："><a href="#Server端：" class="headerlink" title="Server端："></a>Server端：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Com.Dcm.Chat.Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8866</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket sock = ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            Thread t = <span class="keyword">new</span> Handler(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = <span class="keyword">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Client &quot;</span> + sock.getRemoteSocketAddress() + <span class="string">&quot; has connect to Server &quot;</span></span><br><span class="line">                + sock.getLocalSocketAddress() + <span class="string">&quot; Success!&quot;</span>);</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ioe.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String s = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;      <span class="comment">//读取bye后断开连接</span></span><br><span class="line">                writer.write(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Instant ins = Instant.now();</span><br><span class="line">            ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class="line">            System.out.println(zdt + <span class="string">&quot; &gt;&gt;&gt; &quot;</span> + s);</span><br><span class="line">            writer.write(<span class="string">&quot;ok: &quot;</span> + s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client端："><a href="#Client端：" class="headerlink" title="Client端："></a>Client端：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Com.Dcm.Chat.Client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//centOS主机 ： 121.43.173.31; 本机IP：localhost或127.0.0.1;</span></span><br><span class="line">        Socket sock = <span class="keyword">new</span> Socket(<span class="string">&quot;121.43.173.31&quot;</span>, <span class="number">8866</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream input = sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;disconnected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;[server] &quot;</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            String s = scanner.nextLine(); <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.flush();</span><br><span class="line">            String resp = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">&quot;bye&quot;</span>)) &#123;       <span class="comment">//读取bye后，客户端关闭连接</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署到服务器进行测试："><a href="#部署到服务器进行测试：" class="headerlink" title="部署到服务器进行测试："></a>部署到服务器进行测试：</h3><p>在部署到本地（localhost）测试成功后，我尝试在阿里云服务器上运行<code>Server</code>测试。</p><p>首先，使用xftp建立连接传输项目到服务器：</p><p><img src="1.jpg" alt="使用xftp建立连接传输项目到服务器"></p><p>之后使用Xshell连接到服务器对项目进行操作：</p><p>输入相关代码启动服务：</p><p><strong>注意：需要在阿里云控制台启用相关的端口，本次Server端使用8866端口，需要提前开启！</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# cd /usr/local/src/ChatTogether</span><br><span class="line">[root@CentOS ChatTogether]# cd out/production/ChatTogether/</span><br><span class="line">[root@CentOS ChatTogether]# java Com.Dcm.Chat.Server.ServerDemo</span><br></pre></td></tr></table></figure><p>使用IDEA开启Client端，向Server端传输数据：</p><p><img src="2.jpg" alt="使用IDEA开启Client端，向Server端传输数据"></p><p>客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceFiles\Java\jdk-11.0.5\bin\java.exe &quot;-javaagent:D:\SourceFiles\JetBrains\IntelliJ IDEA 2021.1.1\lib\idea_rt.jar=61812:D:\SourceFiles\JetBrains\IntelliJ IDEA 2021.1.1\bin&quot; -Dfile.encoding=UTF-8 -classpath E:\ProgramDemo\ChatTogether\out\production\ChatTogether Com.Dcm.Chat.Client.ClientDemo</span><br><span class="line">[server] hello</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 你好，hello world！</span></span><br><span class="line">&lt;&lt;&lt; ok: 你好，hello world！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 不要回答！</span></span><br><span class="line">&lt;&lt;&lt; ok: 不要回答！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 消灭人类暴政，世界属于三体！</span></span><br><span class="line">&lt;&lt;&lt; ok: 消灭人类暴政，世界属于三体！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 我们是同志了！</span></span><br><span class="line">&lt;&lt;&lt; ok: 我们是同志了！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 北海，要多想！</span></span><br><span class="line">&lt;&lt;&lt; ok: 北海，要多想！</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 没关系的都一样。</span></span><br><span class="line">&lt;&lt;&lt; ok: 没关系的都一样。</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span> </span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ChatTogether]# java Com.Dcm.Chat.Server.ServerDemo</span><br><span class="line">server is running...</span><br><span class="line">connected from /119.102.250.226:61814</span><br><span class="line">Client /119.102.250.226:61814 has connect to Server /172.30.89.4:8866 Success!</span><br><span class="line">2021-08-08T20:44:06.982581+08:00[Asia/Shanghai] &gt;&gt;&gt; 你好，hello world！</span><br><span class="line">2021-08-08T20:44:14.471235+08:00[Asia/Shanghai] &gt;&gt;&gt; 不要回答！</span><br><span class="line">2021-08-08T20:44:26.662957+08:00[Asia/Shanghai] &gt;&gt;&gt; 消灭人类暴政，世界属于三体！</span><br><span class="line">2021-08-08T20:44:33.162085+08:00[Asia/Shanghai] &gt;&gt;&gt; 我们是同志了！</span><br><span class="line">2021-08-08T20:44:47.791487+08:00[Asia/Shanghai] &gt;&gt;&gt; 北海，要多想！</span><br><span class="line">2021-08-08T20:44:59.515964+08:00[Asia/Shanghai] &gt;&gt;&gt; 没关系的都一样。</span><br></pre></td></tr></table></figure><blockquote><p>参考：廖雪峰Java教程 TCP编程 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577">https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java网络编程 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/articles/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<!--此处为希望博客在首页显示的内容--><p>二叉树有多种遍历方法，例如深度优先遍历，广度优先遍历，层次遍历等，本文将对这些遍历方式进行归纳。</p><span id="more"></span><!-- markdownlint-disable MD041 MD002--><p>所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有结点的访问称为遍历(traversal)。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历，深度优先一般用递归或堆栈，广度优先一般用队列。</p><p>我们对二叉树的结点做出如下所示的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> val; </span><br><span class="line">    TreeNode left; </span><br><span class="line">    TreeNode right; </span><br><span class="line">    TreeNode() &#123;&#125; </span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">        <span class="keyword">this</span>.left = left; </span><br><span class="line">        <span class="keyword">this</span>.right = right; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度优先遍历"><a href="#二叉树的深度优先遍历" class="headerlink" title="二叉树的深度优先遍历"></a>二叉树的深度优先遍历</h2><p>深度优先遍历通常有以下三种方式，即先序遍历，中序遍历，后序遍历三种。</p><p><img src="Tree.jpg" alt="奇奇怪怪的二叉树"></p><p>例如如图所示的二叉树，若采用深度优先遍历，有三种方案：</p><ul><li>1.先序遍历，即根左右，先遍历根结点，再依次遍历左结点，右结点。</li><li>2.中序遍历，即左根右，先遍历左结点，再依次遍历根结点，右结点。</li><li>3.后序遍历，即左右根，先依次遍历左结点，右结点，最后再遍历根结点。</li></ul><p>若使用先序遍历，手动得到的结果为：57842913；若使用中序遍历，得到的结果为：87245913；若使用后序遍历，得到的结果为：82473195。</p><p>每一种深度优先遍历方案都有使用显式栈的非递归算法和递归算法。</p><blockquote><p>LeetCode上有关于深度优先遍历的题目，分别是：</p><ul><li>144.二叉树的前序遍历</li><li>145.二叉树的后序遍历</li><li>94.二叉树的中序遍历</li></ul></blockquote><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>递归思路都很简单，即使用递归的方式，依次访问根结点，左结点，右结点。其他的递归方法也与此基本相似。</p><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>所有的递归算法，都要按照三要素来书写：</p><p><strong>1.确定递归函数的参数与返回值</strong><br>即：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。<br><strong>2.确定边界条件</strong><br>即：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。<br><strong>3.确定递归的逻辑</strong><br>即：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p><p>以当前的先序遍历为例：</p><p><strong>1.确定递归函数的参数与返回值:</strong> 本题需要将所有的数据存入ArrayList中，因此并不需要返回值，返回值即<code>void</code>，需要的参数即为根结点的值<code>TreeNode cur</code>和<code>List list</code>。代码为<code>private void preorder(TreeNode cur, List list)</code></p><p><strong>2.确定边界条件:</strong> 边界条件即为若当前遍历的结点值为空，则直接return终止递归。<code>if (cur == NULL) return;</code></p><p><strong>3.确定递归的逻辑:</strong> 递归的逻辑即先访问根结点，再访问左结点，再访问右结点。因此调用的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(cur.val);              <span class="comment">//访问根结点，将其存入list</span></span><br><span class="line">preorder(cur.left, list);       <span class="comment">//访问左结点</span></span><br><span class="line">preorder(cur.right, list);      <span class="comment">//访问右结点</span></span><br></pre></td></tr></table></figure><p>递归算法的时间复杂度为：<code>O(n)</code>，空间复杂度为：<code>O(n)</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode cur, List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;       <span class="comment">//访问到了空结点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(cur.val);      <span class="comment">//访问根结点</span></span><br><span class="line">        preorder(cur.left, list);       <span class="comment">//访问左结点</span></span><br><span class="line">        preorder(cur.right, list);      <span class="comment">//访问右结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode cur, List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;       <span class="comment">//访问到了空结点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(cur.left, list);       <span class="comment">//访问左结点</span></span><br><span class="line">        list.add(cur.val);      <span class="comment">//访问根结点</span></span><br><span class="line">        preorder(cur.right, list);      <span class="comment">//访问右结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode cur, List list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;       <span class="comment">//访问到了空结点，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preorder(cur.left, list);       <span class="comment">//访问左结点</span></span><br><span class="line">        preorder(cur.right, list);      <span class="comment">//访问右结点</span></span><br><span class="line">        list.add(cur.val);      <span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归思路"><a href="#非递归思路" class="headerlink" title="非递归思路"></a>非递归思路</h3><p>以先序遍历为例：因为要在遍历完结点的左子树后接着遍历结点的右子树，为了能找到该结点，需要使用栈来进行暂存。中序和后序也都涉及到回溯，所以都需要用到栈。因此我买了需要手动维护一个栈用来进行数据的暂存。</p><h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//用来存放遍历的结果，即访问顺序</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();      <span class="comment">//用来暂存结点，便于继续搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || root != <span class="keyword">null</span>) &#123;     <span class="comment">//当栈不空或root不为null说明没有遍历完成</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                list.add(root.val);     <span class="comment">//访问根结点将数值存入Arraylist</span></span><br><span class="line">                stack.push(root);       <span class="comment">//将root压入栈中，进行暂存</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();     <span class="comment">//将栈中的结点出栈，准备对其右子树进行访问</span></span><br><span class="line">            root = root.right;      <span class="comment">//访问结点的右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">PreorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; List = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">//用来存放遍历的结果，即访问顺序</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();      <span class="comment">//用来暂存结点，便于继续搜索</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || root != <span class="keyword">null</span>) &#123;     <span class="comment">//当栈不空或root不为null说明没有遍历完成</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若上层出循环，说明已经遍历到左子树的最底层，此时可以将底层数据存入。</span></span><br><span class="line">            list.add(root.val);     <span class="comment">//访问底层结点</span></span><br><span class="line">            root = stack.pop();     <span class="comment">//将上一个结点出栈，尝试访问其右子树</span></span><br><span class="line">            root = root.right;      <span class="comment">//访问右结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h5><p>思路一则是后序遍历在决定是否可以访问当前结点的值的时候，需要考虑其左右子树是否都已经遍历完成。所以需要设置一个lastVisited标记。若lastVisited等于当前考查结点的右子树(说明右侧子树已经遍历完成)，或者当前表示该结点的左右子树都已经遍历完成，则可以访问当前结点。</p><p>因此可以使用如下代码进行后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode lastVisited = root;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;        <span class="comment">//压栈到左子树全部在栈中</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.peek();        <span class="comment">//查看栈顶的元素，若栈顶元素右结点与lastVisited相等或右结点为null说明以遍历完成</span></span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == lastVisited)&#123;</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                lastVisited = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root.right;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h5><p>思路二算是一种简单的奇技淫巧，本质上并不算是后序遍历。我们可以思考：先序遍历是<code>根左右</code>我们可以调整代码的顺序使其很容易变成<code>根右左</code>反转list数组可以使得顺序变为<code>左右根</code>，我们发现此时再进行了两次简单的修改之后，由前序遍历变成了后序遍历。此时我们希望向List的头插入元素实现反转的操作，所以我们使用LinkedList可以有较好的时间性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();        <span class="comment">//使用链表便于头插性能较好</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();      <span class="comment">//使用栈进行结点的暂存</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);       <span class="comment">//暂存root结点</span></span><br><span class="line">                list.add(<span class="number">0</span>, root.val);      <span class="comment">//访问根结点，将结点内容头插加入链表中，实现由根右左到左右根的反转</span></span><br><span class="line">                root = root.right;      <span class="comment">//实现从先序遍历根左右到根右左的转变</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();     <span class="comment">//获取栈顶结点</span></span><br><span class="line">            root = root.left;       <span class="comment">//范围左结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的时间性能略逊于后序遍历的一般解法。使用思路一在LeetCode中提交击败100% Java提交，此方法击败49.89%提交。</p><p>至此所有的非递归算法都保证了格式上的基本统一，方便记忆以及面试时的书写。</p><h2 id="二叉树的广度优先遍历"><a href="#二叉树的广度优先遍历" class="headerlink" title="二叉树的广度优先遍历"></a>二叉树的广度优先遍历</h2><p>在进行深度优先遍历的时候，我们知道了应该使用数据结构栈。那么如何进行广度优先遍历呢，我们可以使用队列这一数据结构。思路如下，首先根结点若不为空，则将根结点放入队列中，每次循环取出队列中的队首元素，将队首元素进行暂存，判断是否可以将该队首节点的左结点右结点入队列(不为null)，并进行计数。当前计数递减为0时，说明一层已经遍历完毕，可以对下一层进行遍历。依次进行相关操作，最终可以得到层序遍历的结果。</p><blockquote><p><strong>LeetCode题目 102.二叉树的层序遍历</strong><br>给你一个二叉树，请你返回其按<strong>层序遍历</strong>得到的节点值。(即逐层地，从左到右访问所有节点)。<br>例如[3,9,20,null,null,15,7]，应返回[ [3], [9,20], [15,7] ]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;      <span class="comment">//设置第一层的结点个数为1</span></span><br><span class="line">        queue.offer(root);      <span class="comment">//将头结点入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                root = queue.poll();        <span class="comment">//将第i层结点出队列</span></span><br><span class="line">                row.add(root.val);          <span class="comment">//将第i层结点放入行中</span></span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;     <span class="comment">//将第i+i层结点入队列</span></span><br><span class="line">                    temp++;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            count = temp;</span><br><span class="line">            list.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IKBC_C104键盘安装白色LED背光</title>
      <link href="/articles/IKBC_C104%E9%94%AE%E7%9B%98%E5%AE%89%E8%A3%85%E7%99%BD%E8%89%B2LED%E8%83%8C%E5%85%89/"/>
      <url>/articles/IKBC_C104%E9%94%AE%E7%9B%98%E5%AE%89%E8%A3%85%E7%99%BD%E8%89%B2LED%E8%83%8C%E5%85%89/</url>
      
        <content type="html"><![CDATA[<!--此处为希望博客在首页显示的内容--><h2 id="键盘的痛点及改灯的理由"><a href="#键盘的痛点及改灯的理由" class="headerlink" title="键盘的痛点及改灯的理由"></a>键盘的痛点及改灯的理由</h2><p>我在19年大一进入学校的时候购入了一把机械键盘，型号是IKBC C104。特色是轴体使用了cherry红轴，PBT键帽，非常适合我这种重度硫酸手的人，此外该键盘性价比极高，在200-300元价位中无出其右。但是有个痛点就是键盘没有带灯，寝室熄灯后敲代码会有些难受(虽然可以盲打，但是仍需要手指去寻找J和F的触点，摸黑还是很难受)因此决定尝试自行安装LED背光。</p><span id="more"></span><!-- markdownlint-disable MD041 MD002--><h2 id="键盘的拆卸"><a href="#键盘的拆卸" class="headerlink" title="键盘的拆卸"></a>键盘的拆卸</h2><p><img src="1.jpg" alt="IKBC C104键盘的外观"></p><p>键盘的拆卸十分容易，键盘本身并未通过螺丝或者胶水进行固定，仅使用了8个卡扣进行上壳和底板的咬合固定。因此使用一字螺丝刀和小拨片去翘一下键盘的接缝处，可以很轻松的将上壳和底座分离，分离后如图所示，且可以看到红色的PCB板。</p><p><img src="2.jpg" alt="键盘进行上下外壳的分离"></p><p>在对外壳进行分离后，我们可以将钢板与PCB板拿离底座，注意，底座和PCB板之间存在排线，需要先将排线分离，再将钢板与PCB板取出。不要直接扯下排线，连接比较紧密，可以不断地晃动排线公口，之后松弛后可以很轻松地拔出排线。</p><p><img src="3.jpg" alt="红色的PCB底座与排线"></p><p>可以看到排线如下所示，不断晃动，即可拔出排线。</p><p><img src="4.jpg" alt="排线的示意图"></p><p>在取下底座之后，即可将键盘的键帽全部拔出(记得拍照作为键盘键位的标记，不然凭借记忆中的键位安装键帽会较为困难)，将所有的键帽拔出之后，可以看到红轴的轴体，在轴体上侧有一个安装F3规格的LED灯的开口，键盘的PCB板上已经存在线路和引脚，只需要将LED安装之后进行焊接即可。</p><p><img src="5.jpg" alt="拆下键帽后的钢板以及PCB板"></p><p>但是拆下键帽后，会发现钢板上有非常多的灰尘和程序猿的头发(头发，我的头发，呜呜呜)，所有使用镊子夹一块医用酒精棉进行擦拭，将油脂，毛发等脏东西清除干净。(PS:感谢舍友淳宝提供的酒精棉，阿里嘎多！)</p><p><img src="6.jpg" alt="用酒精棉擦拭钢板表面，并使用镊子夹出毛发"></p><h2 id="焊接LED灯珠"><a href="#焊接LED灯珠" class="headerlink" title="焊接LED灯珠"></a>焊接LED灯珠</h2><p>在使用了6片酒精棉擦拭(约30min)后，感觉还是键盘的干净度还算是可以看了，如下图，还算比较干净了。此时我们准备这次需要的耗材及工具：</p><blockquote><ul><li>LED灯珠 F3规格 * 104(考虑到存在亮度不均衡，损坏的情况，建议采购120颗起步)       <strong>成本 0.03元 * 104</strong></li><li>电焊及支架 * 1      <strong>成本20元 * 1</strong></li><li>松香 * 1        <strong>成本1元 * 1</strong></li><li>电焊丝 * 1      <strong>成本1元 * 1</strong></li><li>剪线钳 * 1      <strong>成本3元 * 1</strong></li><li>镊子        <strong>成本2元 * 1</strong></li></ul></blockquote><p>使用的这些工具已经在下图中给出，可以按照图片直接购入相应的工具耗材即可。</p><p><img src="7.jpg" alt="耗材工具及清洁后的pcb板"></p><p>将pcb板翻到背面，可以看到为了防止排线线材与较尖的金属触点发生刮蹭导致线材受损，使用了一块比较光滑的硬质塑料片，贴在了背板上。我们可以将这块塑料片拿下，便于LED灯珠的装配与焊接。</p><p><img src="8.jpg" alt="将背板的塑料防护片取下"></p><p>现在开始进行焊接操作，我们可以使用两个手指分别抵住LED灯防止移位和供应焊锡丝(PS:为了翘背板特意留的长指甲，但是并未使用到？拨片一翘就分离了)。这么操作的好处是焊接得到的引脚都非常正，不会弯曲，若之后LED出现故障，可以很轻易地将其取下；但是这样操作也会存在不便，安装到中间的部分将变得异常困难(也可以使用镊子夹住灯珠进行焊接)。所以我为了偷懒使用了较为简单的方式去进行焊接，即将两根引脚分别向两侧弯曲，这样引脚本身的倾斜就导致了不会出现灯珠移位的情况(缺点是若出现故障需要返工，很难将灯珠拔出来)，注意引脚的正负，PCB板上已经标记出了正极引脚。</p><p><img src="9.jpg" alt="对灯珠的引脚进行焊接"></p><p>焊接完成一排之后，我们对灯珠进行点亮测试，可以看到第一排一次性全部被点亮。</p><p><img src="10.jpg" alt="第一排一次点亮"></p><p>有了成功点亮的经验，艺高人胆大(感谢学校的电工实习，咳咳咳)我直接对接下来的两排一并安装灯珠，且全部一次点亮。</p><p><img src="11.jpg" alt="三排成功点亮"></p><p>最后将剩下的三排全部焊接，所有的灯珠在通电后全部一次点亮，非常完美。</p><p><img src="12.jpg" alt="全部灯珠一次点亮"></p><p>我们翻到PCB板的背面，焊点都还能保证比较饱满，由于引脚是歪着焊接的，看上去是歪歪扭扭的，但是还是能保证电气性能良好大。</p><p><img src="13.jpg" alt="PCB背板焊点"></p><p>由于买了150颗灯珠，所以最后还剩下了很多的灯珠，下图是剩下的灯珠和剪断的引脚。</p><p><img src="14.jpg" alt="剩下的灯珠和剪断的引脚"></p><p>装配完成后来看看效果吧！</p><p><img src="15.jpg" alt="装配完成后点亮的效果"></p><p>键盘有很多的灯光方案，老版本的C104有8种点亮方式，新版本的更换过主控后似乎只有3种基本点亮方式了。本人的键盘是在2019年10月购入，此时的版本为老版本，之后是新版本的可能性就大很多了。</p><blockquote><p><strong>点亮效果</strong></p><ul><li>Fn + 1  键盘灯常亮</li><li>Fn + 2  流水闪烁效果(跑马灯)</li><li>Fn + 3  按哪里亮哪里</li><li>Fn + 4  随机闪烁</li><li>Fn + 5  涟漪效果</li><li>Fn + 6  呼吸灯</li><li>Fn + 7  Esc、ASDW、方向键常亮</li><li>Fn + 8  QWER处常亮(可能是LOL的按键)</li><li>Fn + ↑  背光亮度增加</li><li>Fn + ↓  背光亮度降低</li><li>Fn + →  闪烁频率增加</li><li>Fn + ←  闪烁频率降低</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 摸鱼中的小确幸 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用的基本技巧</title>
      <link href="/articles/git%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/"/>
      <url>/articles/git%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!--此处为希望博客在首页显示的内容--><h2 id="导语：git是什么"><a href="#导语：git是什么" class="headerlink" title="导语：git是什么"></a>导语：git是什么</h2><blockquote><p>git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。</p></blockquote><span id="more"></span><!-- markdownlint-disable MD041 MD002--><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h3 id="下载git并直接安装"><a href="#下载git并直接安装" class="headerlink" title="下载git并直接安装"></a>下载git并直接安装</h3><p>在Windows上可以直接在官网下载<a href="https://git-scm.com/downloads">Git安装程序</a>，下载完成后，直接按照步骤进行安装即可，记得选中Add to Path以将其bin目录添加进系统环境中，方便使用。安装完成后，右键选中git bash here，开启bash。</p><h3 id="配置全局参数"><a href="#配置全局参数" class="headerlink" title="配置全局参数"></a>配置全局参数</h3><p>在bash下输入以下代码，全局配置参数，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>输入<code>git config --global --list</code>命令可以显示设置过的全局变量，如下图所示：<br><img src="git_config.png" alt="git config --global --list显示的结果"></p><h2 id="git的基础使用"><a href="#git的基础使用" class="headerlink" title="git的基础使用"></a>git的基础使用</h2><h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p>git仓库即repository，在其中的所有文件均可以被git进行管理，对于文件的新建，修改，删除，git均可以对其进行记录，在进行记录之后，任何事件都可以对历史版本进行追踪、还原等操作。</p><p>创建git仓库的方法非常简单，首先将跳转到合适的路径下，创建一个文件夹（也可以是已经包含文件的文件夹），在bash下可以使用如下代码创建一个git仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /e/ProgramDemo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir Learn_git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/e/ProgramDemo/Learn_git</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>在输入完成后可以发现路径下出现了一个以.git命名的隐藏文件夹，说明仓库创建成功。</p><h3 id="将文件添加到版本库"><a href="#将文件添加到版本库" class="headerlink" title="将文件添加到版本库"></a>将文件添加到版本库</h3><p>在使用<code>git init</code>对git仓库进行建立后，即可在该路径下进行相关项目的创建与书写。</p><p>git可以对这些文件进行跟踪，告知每次文件的修改情况（注意：只能跟踪文本文件，可以监测到添加删除的内容。但对二进制文件无法进行跟踪，只能检测到文件大小发生了变化，因此word文档无法进行跟踪，因为其是二进制文件）在进行文本编辑时，建议使用utf8编码，减少冲突的可能。</p><p>下面对如何将git中的文件添加到仓库进行演示：</p><p>首先在仓库路径下右键选择git bash here打开bash。使用touch命令新建一个测试文件test1.txt，向文件中随意写入一些内容，并进行保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch test1.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test1.txt         <span class="comment"># 随意写入一些内容</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test1.txt</span></span><br><span class="line">Hello world!</span><br><span class="line">This is HeavyTiger!</span><br></pre></td></tr></table></figure><p>写入内容后，可以使用git对文件进行管理了。首先使用命令<code>git status</code>可以看到，git已经检测到我们在路径中创建了新文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        test1.txt</span><br></pre></td></tr></table></figure><p>使用git add命令对文件进行添加，建文件添加到仓库。如果想添加所有的文件，只需要使用<code>git add .</code>命令，即可添加所有文件，如果有不想追踪的文件格式，例如.class文件，可以创建 .gitignore文件对匹配到的相关后缀文件进行忽视。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add test1.txt</span><br><span class="line">git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   test1.txt</span><br></pre></td></tr></table></figure><h3 id="查看修改的内容"><a href="#查看修改的内容" class="headerlink" title="查看修改的内容"></a>查看修改的内容</h3><p>对test1.txt的文件内容进行修改，修改后，可以使用<code>git diff test1.txt</code>命令查看对文件的修改情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim test1.txt     <span class="comment">#对文本文件进行编辑，做出修改</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test1.txt</span></span><br><span class="line">This is HeavyTiger! how are you?</span><br><span class="line">This is a new line which I insert on the second day!</span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff test1.txt</span></span><br><span class="line">diff --git a/test1.txt b/test1.txt</span><br><span class="line">index 02e6d3d..6eac541 100644</span><br><span class="line">--- a/test1.txt</span><br><span class="line">+++ b/test1.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Hello world!</span><br><span class="line">-This is HeavyTiger!</span><br><span class="line">+This is HeavyTiger! how are you?</span><br><span class="line">+This is a new line which I insert on the second day!</span><br></pre></td></tr></table></figure><p>可以看到，文件已经被修改，<code>git diff</code>命令详细给出了行的改变情况。在查询到修改的内容没有问题后，即可放心地将文件进行add与commit操作。（建议在add与commit之前使用<code>git status</code>命令了解代码是否经过了修改，若发现存在修改，可以使用<code>git diff</code>命令查看修改的详细位置）。</p><h3 id="暂存区修改提交至本地仓库"><a href="#暂存区修改提交至本地仓库" class="headerlink" title="暂存区修改提交至本地仓库"></a>暂存区修改提交至本地仓库</h3><p><code>git commit</code>命令可以将暂存区中的修改提交至<strong>本地</strong>的版本库。使用<code>git commit</code>命令会在本地的版本库中生成一个40位的哈希值（原因是多人对项目进行commit时，若使用常规的编码如0、1、2等，会导致产生冲突），称为commit-id，在进行版本回退（<code>git reset</code>）时，需要通过该值进行回退。</p><p>通常会使用命令<code>git commit -m &quot;message&quot;</code>进行版本提交，在添加了-m参数后，可以输入提交信息，在message中需要简洁地对此次提交进行描述，方便查看版本信息。若提交的message过长，想进行更加清楚的描述，可以使用以下方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;</span><br><span class="line">message1</span><br><span class="line">message2</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure><p>此外，若已经提交了一个版本至服务器中（即已进行<code>git commit</code>和<code>git push</code>操作，未被<code>git merge</code>），但是发现版本中出现了小bug，不想再重新提交一个新的版本，可以使用<code>git commit --amend</code>命令进行追加提交提交至前一次版本的commit-id。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>如果在上一次使用<code>git add</code>或<code>git commit</code>之后，你对文件又进行了修改，文件的内容发生了改变，但是我们发现开发出现了不可逆的错误，想直接回退到上次<code>git add</code>或<code>git commit</code>时的状态，撤销工作区中的所有修改，可以使用<code>git checkout -- file</code>命令对其作出修改(如果不添加– file即切换分支，注意<code>git checkout</code>命令是一个危险的命令，可能会替换当前的工作区，请务必在再三确认之后，再键入该命令)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line">Hello world!</span><br><span class="line">this is a new line which I add the second time!</span><br><span class="line">And I deleted the raw second line.</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line">Hello world!</span><br><span class="line">this is a new line which I add the second time!</span><br><span class="line">And I deleted the raw second line.</span><br><span class="line">Add a line which I don&#x27;t want to save.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line">Hello world!</span><br><span class="line">this is a new line which I add the second time!</span><br><span class="line">And I deleted the raw second line.</span><br></pre></td></tr></table></figure><p>如果此时的修改不止存在于工作区下，并且非常憨憨地使用了<code>git add .</code>将所有地修改全部添加到了暂存区，此时显然使用<code>git checkout -- file</code>已经不可能起作用，但是仍然可以进行撤销操作。使用<code>git reset HEAD &lt;file&gt;</code>可以将暂存区中的修改回退到工作区中，使用HEAD表示回退到最新版本。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>我们已经知道了如何对工作区和暂存区中的文件进行版本回退，那么是否可以对已经使用<code>git commit</code>命令提交到本地的版本库中的内容进行回退呢？</p><p>答案是可以的，也需要使用<code>git reset</code>命令进行回退。在向前回退时，可以使用<code>git log</code>命令查看commit-id，通过该id进行版本的回退与更改。查看得到的结果如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a52f403b886f5168b00ad1c91897cf808d26a990 (HEAD -&gt; master)</span><br><span class="line">Author: HeavyTiger &lt;462857080@qq.com&gt;</span><br><span class="line">Date:   Mon Jun 14 16:23:43 2021 +0800</span><br><span class="line"></span><br><span class="line">    The second commitment</span><br><span class="line"></span><br><span class="line">commit 4369702618f9fe107a9e2629446ce4e1d4b2a6a8</span><br><span class="line">Author: HeavyTiger &lt;462857080@qq.com&gt;</span><br><span class="line">Date:   Mon Jun 14 16:19:26 2021 +0800</span><br><span class="line"></span><br><span class="line">    The first commitment</span><br><span class="line"></span><br><span class="line">commit dcd812278c90f6c66a622ae2e6202054d1740f80 (origin/master, origin/HEAD)</span><br><span class="line">Author: HeavyTiger &lt;462857080@qq.com&gt;</span><br><span class="line">Date:   Mon Jun 14 16:10:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br></pre></td></tr></table></figure><p>通过commit-id可以进行版本的回退。使用<code>git reset --hard ID</code>，例如：<code>git reset --hard dcd812</code>回退到Initial commit版本，也可以通过<strong>HEAD</strong>参数进行版本回退，HEAD参数表示当前的版本，在右上角附带^表示上一个版本，故<code>git reset --hard HEAD^</code>表示回退到上一个版本，<code>git reset --hard HEAD^^</code>表示回退到前两个版本。如果回退到前100个版本，也可以使用如下的方法进行回退<code>git reset --hard HEAD~100</code></p><p>但是在进行版本回退之后将无法看到新版本的commit-id，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at 4369702 The first commitment</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (HEAD -&gt; master)</span><br><span class="line">Author: HeavyTiger &lt;462857080@qq.com&gt;</span><br><span class="line">Date:   Mon Jun 14 16:19:26 2021 +0800</span><br><span class="line"></span><br><span class="line">    The first commitment</span><br><span class="line"></span><br><span class="line">commit dcd812278c90f6c66a622ae2e6202054d1740f80 (origin/master, origin/HEAD)</span><br><span class="line">Author: HeavyTiger &lt;462857080@qq.com&gt;</span><br><span class="line">Date:   Mon Jun 14 16:10:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以此时如何找到最新的版本号呢？可以使用<code>git reflog</code>命令查看commit记录，在reflog中记录了commit-id，因此可以很方便地向后进行跳转，找到最新commit的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">4369702 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">a52f403 HEAD@&#123;1&#125;: reset: moving to a52f</span><br><span class="line">4369702 (HEAD -&gt; master) HEAD@&#123;2&#125;: reset: moving to 4369</span><br><span class="line">a52f403 HEAD@&#123;3&#125;: commit: The second commitment</span><br><span class="line">4369702 (HEAD -&gt; master) HEAD@&#123;4&#125;: commit: The first commitment</span><br><span class="line">dcd8122 (origin/master, origin/HEAD) HEAD@&#123;5&#125;: clone: from github.com:HeavyTiger/Learn_git.git</span><br></pre></td></tr></table></figure><h2 id="git的目录结构"><a href="#git的目录结构" class="headerlink" title="git的目录结构"></a>git的目录结构</h2><p>git中加入了暂存区的概念，分为工作区，版本库中的暂存区，分支等概念。git版本库的模型如下图所示：</p><p><img src="git_model.png" alt="git版本库的模型"></p><p>上图描述了 git 对象的在不同的生命周期中不同的存储位置，通过不同的 git 命令改变 git 对象的存储生命周期。</p><h3 id="工作区-workspace"><a href="#工作区-workspace" class="headerlink" title="工作区(workspace)"></a>工作区(workspace)</h3><p>就是我们当前工作空间，也就是我们当前能在本地文件夹下面看到的文件结构。初始化工作空间或者工作空间 clean 的时候，文件内容和 index 暂存区是一致的，随着修改，工作区文件在没有 add 到暂存区时候，工作区将和暂存区是不一致的。</p><h3 id="暂存区-index"><a href="#暂存区-index" class="headerlink" title="暂存区 (index)"></a>暂存区 (index)</h3><p>老版本概念也叫 Cache 区，就是文件暂时存放的地方，所有暂时存放在暂存区中的文件将随着一个 commit 一起提交到 local repository 此时 local repository 里面文件将完全被暂存区所取代。暂存区是 git 架构设计中非常重要和难理解的一部分。</p><h3 id="本地仓库-local-repository"><a href="#本地仓库-local-repository" class="headerlink" title="本地仓库 (local repository)"></a>本地仓库 (local repository)</h3><p>git 是分布式版本控制系统，和其他版本控制系统不同的是他可以完全去中心化工作，你可以不用和中央服务器 (remote server) 进行通信，在本地即可进行全部离线操作，包括 log，history，commit，diff 等等。完成离线操作最核心是因为 git 有一个几乎和远程一样的本地仓库，所有本地离线操作都可以在本地完成，等需要的时候再和远程服务进行交互。</p><h3 id="远程仓库-remote-repository"><a href="#远程仓库-remote-repository" class="headerlink" title="远程仓库 (remote repository)"></a>远程仓库 (remote repository)</h3><p>中心化仓库，所有人共享，本地仓库会需要和远程仓库进行交互，也就能将其他所有人内容更新到本地仓库把自己内容上传分享给其他人。结构大体和本地仓库一样。</p><h3 id="git命令后文件的变化"><a href="#git命令后文件的变化" class="headerlink" title="git命令后文件的变化"></a>git命令后文件的变化</h3><p><img src="git_fileChange.png" alt="git命令后文件的变化"></p><p>Git管理的是修改，当使用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>所以在每次使用<code>git commit</code>之前，所有修改过的文件都必须重新进行<code>git add</code>，将工作区(workspace)中的修改提交到暂存区(index)中，否则即使进行了<code>git commit</code>本地仓库中也将不会出现修改。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>在<a href="https://github.com/">github</a>或者<a href="https://gitee.com/">gitee</a>网站中注册帐号，创建Repository，作为本地的远程仓库。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在GitHub中，得到仓库的SSH链接或者HTTPS链接，将该链接手动绑定到本地。例如，本人学习git的项目的SSH链接为：<a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>:HeavyTiger/Learn_git.git，故可以在本地的仓库中，使用bash输入<code>git remote add origin git@github.com:HeavyTiger/Learn_git.git</code>命令，使用此命令可以让远端仓库与本地仓库建立远程连接，而该远程仓库名叫做<code>origin</code>(初始建立的远程连接，一般都叫做origin，clone得到的仓库亦叫origin)。</p><p>下一步即可及那个本地库中的内容推送到远程库上：使用命令<code>git push</code>，第一次进行数据上传建议使用<code>git push -u origin master</code>加上了-u参数后，Git会将本地的master分支与远程的master分支进行关联，在之后的推送中即可简化命令<code>git push origin master</code>。</p><p>使用该方法时，记得查看GitHub与本地的文件是否一致，GitHub在创建仓库时会添加readME.md以及.gitignore文件，若本地不存在这些文件，即两边的版本库不同步，在使用<code>git push</code>命令时会产生报错，因此建议使用此方法时，需要将本地的版本库与远程的版本库进行同步。使用<code>git pull</code>命令从远端进行拉取，将版本库与远端同步，之后即可正常的提交代码。因此不建议采用方法一中的方法。因为较为复杂，可以使用方法二中的方法。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>先创建一个远程库，直接进行远程库克隆，即使用<code>git clone</code>命令将远程库与本地库直接关联并且同步数据，由于账户中保存了本机的公匙，因此可以直接将本机的文件进行推送，如果clone他人的项目，自然无法进行推送。如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用https之类的协议进行上传，例如<a href="https://github.com/HeavyTiger/Learn_git.git">https://github.com/HeavyTiger/Learn_git.git</a> 这样的地址。实际上，Git支持多种协议，默认的Git使用SSH进行连接，但也可以使用https等其他协议。</p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>使用<code>git checkout -b name</code>创建分支并转到新建的分支上。例如创建dev分支，即可以使用<code>git ckeckout -b dev</code>创建dev分支并跳转到dev分支上。</p><p>使用<code>git branch</code>命令可以查看当前的所有分支，在当前分支前会有一个<code>*</code>号。</p><p>可以在<code>dev</code>分支上进行修改以及提交而不会影响<code>master</code>分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span> &gt; hello.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;the first dev modify&quot;</span></span></span><br><span class="line">[dev a1d3fec] the first dev modify</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  test.txt</span><br></pre></td></tr></table></figure><p>可以看到对dev分支下新建了hello.txt并提交之后，转到master分支，并不存在dev分支下新建立的hello.txt文件。</p><p>但是若要转到master分支后本地工作区中的文件不被直接同步为dev分支下创建的内容，必须要执行<code>git add</code>和<code>git commit</code>命令，否则会导致出错，本地的工作区文件将在跳转后直接被同步为dev分支下修改的内容。</p><h4 id="git-stash暂存"><a href="#git-stash暂存" class="headerlink" title="git stash暂存"></a>git stash暂存</h4><p>如果不想使用<code>git commit</code>进行一次提交该如何操作？比方说，正在对dev分支进行修改，已经做出了部分修改，此时收到了新的命令，即再去另一个分支对bug进行修复，若此时不进行<code>git commit</code>去提交<code>dev</code>分支，在转换分支时会导致数据被合并到出现bug的分支上，回退会导致数据丢失。因此我们可以先使用<code>git add .</code>将工作区中的修改储存到暂存区(<strong>重要</strong>)，再使用<code>git stash</code>命令进行暂存区的暂存。再处理完另一个分支的bug后，可以回退到<code>dev</code>分支下，进行数据的恢复，演示操作如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;this is a temp file.&quot;</span> &gt; temp1.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;this is a temp file.&quot;</span> &gt; temp2.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  temp1.txt  temp2.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        temp1.txt</span><br><span class="line">        temp2.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line">Saved working directory and index state WIP on dev: a1d3fec the first dev modify</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on dev: a1d3fec the first dev modify</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   temp1.txt</span><br><span class="line">        new file:   temp2.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (77cfbe0f5b75e14d8118f607d88d42c7e0ac3bc4)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  temp1.txt  temp2.txt  test.txt</span><br></pre></td></tr></table></figure><p>可以看到此时的数据被成功恢复。</p><blockquote><p>(储存)</p></blockquote><ul><li>首先使用<code>git add .</code></li><li>再使用<code>git stash save &quot;备注&quot;</code></li><li>最后使用<code>git stash list</code>查看stash的情况是否正常 </li></ul><blockquote><p>(恢复)</p></blockquote><ul><li>当bug修复完毕时，使用<code>git stash pop</code>(当前现场需要在栈顶)</li><li>若暂存多次，可以使用<code>git stash apply stash@&#123;1&#125;</code>命令进行恢复，</li><li><code>stash@&#123;1&#125;</code>即stash内容的版本，可以使用<code>git stash list</code>进行查看，<br>但是使用<code>git stash apply</code>恢复会导致stash内容不被删除，毕竟使用到了栈，需要手动使用<code>git stash drop</code>来删除。</li></ul><h4 id="快速修复其他分支的相同问题"><a href="#快速修复其他分支的相同问题" class="headerlink" title="快速修复其他分支的相同问题"></a>快速修复其他分支的相同问题</h4><p>同时，在修复bug的情景下，我们可能会想到修复的bug在其他分支上也存在，有没有办法仅仅将修改bug的位置同步到其他分支呢？为此，git提供了<code>cherry-pick</code>命令，允许进行相应的此操作，将一次提交中所做出的修改提交到当前分支上，找到<code>fix bug</code>的<code>commit-id</code>，对当前的分支使用命令<code>git cherry-pick commit-id</code>即可将修改的bug同步到当前的分支。git会自动给当前分支进行一次<code>git commit</code>操作。两次提交的<code>commit-id</code>不相同，原因是这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在当前分支上手动再把修bug的过程重复一遍。</p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>合并分支需要使用到<code>git merge branch</code>命令，将其他的分支合并到HEAD所指向的分支上，如果有冲突，则无法合并，需要手动对冲突进行修复后才能进行合并。如果能够直接合并，会使用Fast-forward的方式进行合并。即直接将当前的分支指针(被合并的)指向合并的分支上，所以速度非常快。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is up to date with &#x27;origin/master&#x27;.</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Updating 4369702..a1d3fec</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 1 +</span><br><span class="line"> test.txt  | 5 +++--</span><br><span class="line"> 2 files changed, 4 insertions(+), 2 deletions(-)</span><br><span class="line"> create mode 100644 hello.txt</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>在合并完分支后，对于无用的分支，即可直接删除，使用<code>git branch -d dev</code>命令即可将dev分支删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br><span class="line">Deleted branch dev (was a1d3fec).</span><br></pre></td></tr></table></figure><h3 id="合并冲突处理"><a href="#合并冲突处理" class="headerlink" title="合并冲突处理"></a>合并冲突处理</h3><p>首先，git在对分支进行合并的时候，可能会出现无法合并的情况。例如，同一篇作文，老师对开头进行了修改，而作者对结尾进行了修改，这种情况是可以直接进行合并的，使用<code>git merge</code>命令可以自动进行合并。但是如果老师修改了开头，作者也想修改开头，则没有办法对文章进行自动合并，需要作者或老师对文章开头的修改进行手动合并，在手动处理冲突完成后(即决定将谁对开头的修改作为整篇文章的修改)，之后才能够进行文章的自动合并。举例说明如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim hello.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">Hello world means ni hao in chinese!</span><br><span class="line">I modified this file.</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">&quot;修改了hello.txt，对HelloWorld含义做出解释&quot;</span></span></span><br><span class="line">[dev f5228b6] 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f5228b6a8d1b5c52d3672369b13227217d5ea339 (HEAD -&gt; dev) 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">a1d3fec8d4b76de78627db0c9c41a9d0e16d0769 (origin/dev, master) the first dev modify</span><br><span class="line">0ccccf8dd1b842302270dac680fa01fccbe3e002 the first modify in branch dev</span><br><span class="line">4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">dcd812278c90f6c66a622ae2e6202054d1740f80 Initial commit</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim hello.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">Hello world, this is another way to modify.</span><br><span class="line">ni hao!</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">&quot;在主分支中修改了hello.txt，欲展示合并冲突处理过程&quot;</span></span></span><br><span class="line">[master 42eede8] 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">42eede8aed5975b65ee866223ce642b3f8cc23e7 (HEAD -&gt; master) 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">a1d3fec8d4b76de78627db0c9c41a9d0e16d0769 (origin/dev) the first dev modify</span><br><span class="line">0ccccf8dd1b842302270dac680fa01fccbe3e002 the first modify in branch dev</span><br><span class="line">4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">dcd812278c90f6c66a622ae2e6202054d1740f80 Initial commit</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit --all</span></span><br><span class="line">* 42eede8 (HEAD -&gt; master) 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">| * f5228b6 (dev) 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">|/</span><br><span class="line">* a1d3fec (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8 the first modify in branch dev</span><br><span class="line">* 4369702 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd8122 Initial commit</span><br></pre></td></tr></table></figure><p>可以使用<code>git log --graph --pretty=oneline --abbrev-commit --all</code>语句以图表的形式展示所有<code>git commit</code>的情况，其中：</p><blockquote><ul><li><code>--graph</code>参数表示以图标的形式进行显示提交情况。</li><li><code>--pretty=oneline</code>参数表示精简输出，每一次<code>git commit</code>提交均在一行内进行显示。</li><li><code>--abbrev-commit</code>参数表示将commit-ID进行简写，将40个十六进制数的SHA1散列值进行简写，使用7位16进制数进行表示。</li><li><code>--all</code>参数表示展示所有分支中的提交情况，否则只会展示当前分支下的提交情况</li></ul></blockquote><p>图中带有(origin/dev)等字样的表示在远程仓库中进行过提交，存在提交记录，可以直接进行恢复。</p><p>此时对修改进行合并，合并到主分支上，可以看到git提示我们在hello.txt中出现了冲突，自动合并失败，需要我们手动将HEAD所指向的分支中的文件修改后，直接进行提交，才可以进行合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>查看当前路径下hello.txt文件中的内容，可以看到，git使用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code>将出现冲突的地方进行了标记，我们对冲突进行判断并保留，之后进行提交，即可完成合并的操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Hello world, this is another way to modify.</span><br><span class="line">ni hao!</span><br><span class="line"> =======</span><br><span class="line">Hello world means ni hao in chinese!</span><br><span class="line">I modified this file.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; dev</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim hello.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">Hello world, this is another way to modify.</span><br><span class="line">ni hao!I modified this file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">&quot;conflict fixed&quot;</span></span></span><br><span class="line">[master 7373637] conflict fixed</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit --all</span></span><br><span class="line">*   7373637 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * f5228b6 (dev) 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">* | 42eede8 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">|/</span><br><span class="line">* a1d3fec (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8 the first modify in branch dev</span><br><span class="line">* 4369702 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd8122 Initial commit</span><br></pre></td></tr></table></figure><h3 id="禁用Fast-forward模式"><a href="#禁用Fast-forward模式" class="headerlink" title="禁用Fast forward模式"></a>禁用Fast forward模式</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。即如果不禁用，若可以以此模式合并，会直接将HEAD移动到最新的dev版本上，会导致分支的信息直接丢失，在多人开发的情况下这样是不好的，需要再强制进行一次<code>git commit</code>操作，则会生成两个节点，将HEAD指向新生成的节点即可。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline</span></span><br><span class="line">*   73736377bbeccfefe5121f2bab028b13784b66e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * f5228b6a8d1b5c52d3672369b13227217d5ea339 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">* | 42eede8aed5975b65ee866223ce642b3f8cc23e7 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">|/</span><br><span class="line">* a1d3fec8d4b76de78627db0c9c41a9d0e16d0769 (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8dd1b842302270dac680fa01fccbe3e002 the first modify in branch dev</span><br><span class="line">* 4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd812278c90f6c66a622ae2e6202054d1740f80 Initial commit</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">  develop</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --all</span></span><br><span class="line">* 20a793580c3af6a1f9117a2142e589ebffe2d3a3 (develop) 在develop分支中增加对noff.txt文件的修改</span><br><span class="line">*   73736377bbeccfefe5121f2bab028b13784b66e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * f5228b6a8d1b5c52d3672369b13227217d5ea339 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">* | 42eede8aed5975b65ee866223ce642b3f8cc23e7 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">|/</span><br><span class="line">* a1d3fec8d4b76de78627db0c9c41a9d0e16d0769 (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8dd1b842302270dac680fa01fccbe3e002 the first modify in branch dev</span><br><span class="line">* 4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd812278c90f6c66a622ae2e6202054d1740f80 Initial commit</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge develop</span></span><br><span class="line">Updating 7373637..20a7935</span><br><span class="line">Fast-forward</span><br><span class="line"> noff.txt | 3 +++</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 noff.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --all</span></span><br><span class="line">* 20a793580c3af6a1f9117a2142e589ebffe2d3a3 (HEAD -&gt; master, develop) 在develop分支中增加对noff.txt文件的修改</span><br><span class="line">*   73736377bbeccfefe5121f2bab028b13784b66e4 conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * f5228b6a8d1b5c52d3672369b13227217d5ea339 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">* | 42eede8aed5975b65ee866223ce642b3f8cc23e7 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">|/</span><br><span class="line">* a1d3fec8d4b76de78627db0c9c41a9d0e16d0769 (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8dd1b842302270dac680fa01fccbe3e002 the first modify in branch dev</span><br><span class="line">* 4369702618f9fe107a9e2629446ce4e1d4b2a6a8 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd812278c90f6c66a622ae2e6202054d1740f80 Initial commit</span><br></pre></td></tr></table></figure><p>在进行Fast forward之后，可以看到，当前的HEAD直接指向了master以及develop，相当于丢失了一次分支，我们再对develop分支进行一次更新提交，禁止Fast forward。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch &#x27;develop&#x27;</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">README.md  hello.txt  noff.txt  test.txt</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim noff.txt</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;尝试对develop分支进行修改，此次尝试不使用Fast forward合并&quot;</span></span></span><br><span class="line">[develop d6bc5fc] 尝试对develop分支进行修改，此次尝试不使用Fast forward合并</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (develop)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;进制Fast forward模式合并&quot;</span> develop</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> noff.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">DCM@DESKTOP-GN199F8 MINGW64 /e/ProgramDemo/Learn_git (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit --all</span></span><br><span class="line">*   e0aa011 (HEAD -&gt; master) 进制Fast forward模式合并</span><br><span class="line">|\</span><br><span class="line">| * d6bc5fc (develop) 尝试对develop分支进行修改，此次尝试不使用Fast forward合并</span><br><span class="line">|/</span><br><span class="line">* 20a7935 在develop分支中增加对noff.txt文件的修改</span><br><span class="line">*   7373637 conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * f5228b6 修改了hello.txt，对HelloWorld含义做出解释</span><br><span class="line">* | 42eede8 在主分支中修改了hello.txt，欲展示合并冲突处理过程</span><br><span class="line">|/</span><br><span class="line">* a1d3fec (origin/dev) the first dev modify</span><br><span class="line">* 0ccccf8 the first modify in branch dev</span><br><span class="line">* 4369702 (origin/master, origin/HEAD) The first commitment</span><br><span class="line">* dcd8122 Initial commit</span><br></pre></td></tr></table></figure><p>可以看到再这次提交之后，使用<code>-m</code>参数进行了一次版本提交，因此保留了该分支存在的证据和记录，而之前没有使用<code>--no-ff</code>参数合并的develop版本已经找不到存在的证据了。合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h3 id="开发中的分支策略"><a href="#开发中的分支策略" class="headerlink" title="开发中的分支策略"></a>开发中的分支策略</h3><p>在实际开发中，我们应该保证master分支的永远稳定，仅用来发布最新的使用版本，不允许直接在master分支上进行开发。</p><p>我们应该使用dev分支（即develop开发分支）进行开发，对于已经稳定的版本再合并到master分支上。</p><p>每个开发人员都有自己的分支，同时，也可以一个人开辟多条分支，进行修改与特性增加。在经过项目管理人员的批准后，时不时向dev分支上合并即可。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 代码版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
